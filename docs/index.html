<!DOCTYPE html>
<html>
<head>
	<meta name="generator" content="Hugo 0.126.1">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>大峰哥 - 记录日常生活哦 </title><meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="alternate" type="application/rss+xml" href="https://wfsui.github.io/index.xml" title="大峰哥" />
	<meta property="og:url" content="https://wfsui.github.io/">
  <meta property="og:site_name" content="大峰哥">
  <meta property="og:title" content="大峰哥">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="website">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="大峰哥">
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/main.css" /><link rel="stylesheet" type="text/css" href="https://wfsui.github.io/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="https://wfsui.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	<base href="https://wfsui.github.io/">
	<h1 class="site-title"><a href="https://wfsui.github.io/">大峰哥</a></h1>
	<div class="site-description"><h2>记录日常生活哦</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/wfsui" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">首页</a>
			</li>
			
			<li>
				<a href="/posts">文章</a>
			</li>
			
			<li>
				<a href="/about">关于</a>
			</li>
			
			<li>
				<a href="/tags">标签</a>
			</li>
			
		</ul>
	</nav>
</div>


		

		<div class="recent-posts section">
			<h2 class="section-header">
				Recent posts
			</h2>
			<div class="posts">
				
				
				
				<div class="post">
					<div class="meta">May 26, 2024</div>
					<a class="title" href="/posts/%E7%AE%97%E6%B3%95%E4%B8%AD%E4%B8%83%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">算法中七种常见的时间复杂度</a> &mdash;
					<span class="description">
						
						这是我的推广信息，以激励自己更好的分享自己的知识和经验！也希望看到的你能够多多支持，谢谢！
1. 滴滴云AI大师: 目前滴滴云正在大力推广自己的云计算服务，需要购买的朋友们用我的AI大师码 「2049」在滴滴云上购买 GPU / vGPU / 机器学习产品可额外享受 9 折优惠，点击这里前往滴滴云官网：www.didiyun.com。
原文地址：7 Helpful Time Complexities 原文作者：Ellis Andrews 译文出自：掘金翻译计划 本文永久链接：https://github.&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">May 26, 2024</div>
					<a class="title" href="/posts/java%E9%AD%94%E6%B3%95%E7%B1%BBunsafe%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/">Java魔法类：Unsafe应用解析</a> &mdash;
					<span class="description">
						
						前言 Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。
注：本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。
基本介绍 如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。
public final class Unsafe { // 单例对象 private static final Unsafe theUnsafe; private Unsafe() { } @CallerSensitive public static Unsafe getUnsafe() { Class var0 = Reflection.&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">May 26, 2024</div>
					<a class="title" href="/posts/java%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/">Java动态追踪技术探究</a> &mdash;
					<span class="description">
						
						引子 在遥远的希艾斯星球爪哇国塞沃城中，两名年轻的程序员正在为一件事情苦恼，程序出问题了，一时看不出问题出在哪里，于是有了以下对话：
“Debug一下吧。”
“线上机器，没开Debug端口。”
“看日志，看看请求值和返回值分别是什么？”
“那段代码没打印日志。”
“改代码，加日志，重新发布一次。”
“怀疑是线程池的问题，重启会破坏现场。”
长达几十秒的沉默之后：“据说，排查问题的最高境界，就是只通过Review代码来发现问题。”
比几十秒长几十倍的沉默之后：“我轮询了那段代码一十七遍之后，终于得出一个结论。”
“结论是？”
“我还没到达只通过Review代码就能发现问题的至高境界。”
从JSP说起 对于大多数Java程序员来说，早期的时候，都会接触到一个叫做JSP（Java Server Pages）的技术。虽然这种技术，在前后端代码分离、前后端逻辑分离、前后端组织架构分离的今天来看，已经过时了，但是其中还是有一些有意思的东西，值得拿出来说一说。
当时刚刚处于Java入门时期的我们，大多数精力似乎都放在了JSP的页面展示效果上了：
“这个表格显示的行数不对”
“原来是for循环写的有问题，改一下，刷新页面再试一遍”
“嗯，好了，表格显示没问题了，但是，登录人的姓名没取到啊，是不是Sesstion获取有问题？”&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">May 26, 2024</div>
					<a class="title" href="/posts/mjdk-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%8B%E7%BC%A9%E9%80%9F%E7%8E%87%E7%9A%84-5-%E5%80%8D%E6%8F%90%E5%8D%87/">MJDK 如何实现压缩速率的 5 倍提升？</a> &mdash;
					<span class="description">
						
						1 前言 数据压缩技术[1]因可有效降低数据存储及传输成本，在计算机领域有非常广泛的应用（包括网络传输、文件传输、数据库、操作系统等场景）。主流压缩技术按其原理可划分为无损压缩[2]、有损压缩[3]两类，工作中我们最常用的压缩工具 zip 和 gzip ，压缩函数库 zlib，都是无损压缩技术的应用。Java 应用中对压缩库的使用包括：处理 HTTP 请求时对 body 的压缩/解压缩操作、使用消息队列服务时对大消息体（如&gt;1M）的压缩/解压缩、数据库写入前及读取后对大字段的压缩/解压缩操作等。常见于监控、广告等涉及大数据传输/存储的业务场景。
美团基础研发平台曾经开发过一种基于 Intel 的 isa-l 库优化的 gzip 压缩工具及 zlib[4] 压缩库（又称：mzlib[5] 库），优化后的压缩速度可提升 10 倍，解压缩速度能提升 2 倍，并已在镜像分发、图片处理等场景长期稳定使用。遗憾的是，受限于 JDK[6] 对压缩库调用的底层设计，公司 Java8 服务一直无法使用优化后的 mzlib 库，也无法享受压缩/解压缩速率提升带来的收益。为了充分发挥 mzlib 的性能优势为业务赋能，在 MJDK 的最新版本中，我们改造并集成了 mzlib 库，完成了JDK中 java.&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">May 26, 2024</div>
					<a class="title" href="/posts/%E7%BE%8E%E5%9B%A2%E5%A4%9A%E5%9C%BA%E6%99%AF%E5%BB%BA%E6%A8%A1%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/">美团多场景建模的探索与实践</a> &mdash;
					<span class="description">
						
						1 引言 美团到家Demand-Side Platform（下文简称DSP）平台，主要负责在美团外部媒体上进行商品或者物料的推荐和投放，并不断优化转化效果。随着业务的不断发展与扩大，DSP对接的外部渠道越来越丰富、展示形式越来越多样，物料展示场景的差异性愈发明显（如开屏、插屏、信息流、弹窗等）。
例如，用户在午餐时间更容易点击【某推荐渠道下】【某App】【开屏展示位】的快餐类商家的物料而不是【信息流展示位】的啤酒烧烤类商家物料。场景间差异的背后本质上是用户意图和需求的差异，因此模型需要对越来越多的场景进行定制化建设，以适配不同场景下用户的个性化需求。
业界经典的Mixture-of-Experts架构（MoE，如MMoE、PLE、STAR[1]等）能一定程度上适配不同场景下用户的个性化需求。这种架构将多个Experts的输出结果通过一个门控网络进行权重分配和组合，以得到最终的预测结果。早期，我们基于MoE架构提出了使用物料推荐渠道进行场景划分的多场景建模方案。然而，随着业务的不断壮大，场景间的差异越来越大、场景数量也越来越丰富，这版模型难以适应业务发展，不能很好地解决DSP背景下存在的以下两个问题：
负迁移现象：以推荐渠道为例，由于不同推荐渠道的流量在用户分布、行为习惯、物料展示形式等方面存在差异，其曝光数、点击率也不在同一个数量级（如下图1所示，不同渠道间点击率相差十分显著），数据呈现典型的“长尾”现象。如果使用推荐渠道进行多场景建模的依据，一方面模型会更倾向于学习到头部渠道的信息，对于尾部渠道会存在学习不充分的问题，另一方面尾部渠道的数据也会给头部渠道的学习带来“噪声”，导致出现负迁移。 数据稀疏难以收敛：DSP会在外部不同媒体上进行物料展示，而用户在访问外部媒体时，其所处的时空背景、上下文信息、不同App以及物料展示位等信息共同构成了当前的场景，这样的场景在十万的量级，每个场景的数据又十分稀疏，导致模型难以在每个场景上得到充分的训练。 在面对此类建模任务时，业界现有的方法是在不同场景间进行知识迁移。例如，SAML[2]模型采用辅助网络来学习场景的共享知识并迁移至各场景的独有网络；ADIN[3]和SASS[4]模型使用门控单元以一种细粒度的方式来选择和融合全局信息到单场景信息中。然而，在DSP背景中复杂多变的流量背景下，场景差异性导致了场景数量的急剧增长，现有方法无法在巨量稀疏场景下有效。
因此，在本文中我们提出了DSP背景下的自适应场景建模方案（AdaScene, Adaptive Scenario Model），同时从知识迁移和场景聚合两个角度进行建模。AdaScene通过控制知识迁移的程度来最大化不同场景共性信息的利用，并使用稀疏专家聚合的方式利用门控网络自动选择专家组成场景表征，缓解了负迁移现象；同时，我们利用损失函数梯度指导场景聚合，将巨大的推荐场景空间约束到有限范围内，缓解了数据稀疏问题，并实现了自适应场景建模方案。
2 自适应场景建模 在本节开始前，我们先介绍多场景模型的建模方式。多场景模型采用输入层 Embedding + 混合专家（Mixture-of-Experts, MoE）的建模范式，其中输入信息包括了用户侧、商家侧以及场景上下文特征。多场景模型的损失由各场景的损失聚合而成，其损失函数形式如下：&hellip;
						
					</span>
				</div>
				
				

<ul class="pagination">
	<li class="page-item page-prev">
	
	</li>
	<li class="page-item page-next">
	
    <a href="/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">Next page →</span></a>
	
	</li>
</ul>


			</div>
		</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="">Wfsui theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div><script>feather.replace()</script>
</body>
</html>
