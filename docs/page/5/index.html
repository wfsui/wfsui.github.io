<!DOCTYPE html>
<html>
<head>
	<meta name="generator" content="Hugo 0.123.8">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>大峰哥 - 记录日常生活哦 </title><meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="alternate" type="application/rss+xml" href="https://wfsui.github.io/index.xml" title="大峰哥" />
	<meta property="og:title" content="大峰哥" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://wfsui.github.io/" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="大峰哥"/>
<meta name="twitter:description" content=""/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/main.css" /><link rel="stylesheet" type="text/css" href="https://wfsui.github.io/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="https://wfsui.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	<base href="https://wfsui.github.io/">
	<h1 class="site-title"><a href="https://wfsui.github.io/">大峰哥</a></h1>
	<div class="site-description"><h2>记录日常生活哦</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/wfsui" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">首页</a>
			</li>
			
			<li>
				<a href="/posts">文章</a>
			</li>
			
			<li>
				<a href="/about">关于</a>
			</li>
			
			<li>
				<a href="/tags">标签</a>
			</li>
			
		</ul>
	</nav>
</div>


		

		<div class="recent-posts section">
			<h2 class="section-header">
				Recent posts
			</h2>
			<div class="posts">
				
				
				
				<div class="post">
					<div class="meta">Mar 12, 2024</div>
					<a class="title" href="/posts/%E7%BE%8E%E5%9B%A2rasp%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%A0%94%E5%8F%91%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">美团RASP大规模研发部署实践总结</a> &mdash;
					<span class="description">
						
						背景 RASP是Runtime Application Self-Protection（运行时应用自我保护）的缩写，是一种应用程序安全技术。RASP 技术能够在应用程序运行时检测并阻止应用级别的攻击。随着云计算和大数据的发展，应用程序安全越来越受到重视。RASP 技术作为一种新型的安全防护手段，正在逐渐被业界接受并广泛应用。其中Java RASP 是一种针对 Java 应用程序的 RASP 技术。通过在 Java 虚拟机（JVM）级别进行监控和防护，能够有效防止对 Java 应用程序的攻击。
RASP建设挑战 在业界，RASP的部署形式一般有agentmain、premain两种方式，二者各有优劣。适合不同的业务场景，以及安全需求。
agentmain：业务无需改动，无需重启，热插拔，动态升级。有性能抖动，业务有感知。 premain：需要改动，需要重启，前置注入，升级需要重启。无性能抖动，业务无感知。 美团的RASP建设时，大部分业务都已经在线上运营，而且有多个发布平台，没有提供一个统一的方式来更改启动参数，也就是说无法通过premain方式是实现快速部署。为了抓住主要矛盾，快速解决大部分风险问题，我们选择了agentmain方式。&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Mar 12, 2024</div>
					<a class="title" href="/posts/%E7%BE%8E%E5%9B%A2%E5%88%B0%E5%BA%97%E7%BB%88%E7%AB%AF%E4%BB%8E%E6%A0%87%E5%87%86%E5%8C%96%E5%88%B0%E6%95%B0%E5%AD%97%E5%8C%96%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/">美团到店终端从标准化到数字化的演进之路</a> &mdash;
					<span class="description">
						
						1 背景 在我们日常工作中，要实现需求的快速和高质量交付，关键在于提升效率和质量。然而，在实践中很难找到一个通用策略，能同时针对效率和质量进行优化。这是因为在不同的场景下，对效率和质量会产生不同的解读。例如，在需求研发阶段，研发团队可能更注重提升工程效率和代码质量；而测试团队可能会更关注平台的稳定性和需求的质量；产品团队则可能聚焦于缩短交付周期和提高资源的有效使用。
在深入探讨具体的研发场景时，我们遇到了若干挑战。首先，一个完整的交付流程涵盖了从需求开发到产品上线的各个阶段，涉及产品、研发、测试等关键角色，每个人的职责各有侧重，且整个过程依赖于持续的沟通与协作。在这个环节中，我们常会遇到这样的问题：尽管每个人都忙碌，但整体效率却并没有明显的提升；即便对单一环节进行了优化，但优化效果并没有直接让整个需求的时间缩短，有时甚至会导致资源等待时间变长。
对于第一个问题，这通常不是个人能力的问题，而是因为我们在产研协同流程或资源管理工具上还有改进的空间。而第二个问题，可以举个例子这样理解：假设一个研发任务预计需要3天完成，一个高效的研发人员可能在1天内就完成了开发工作。然而，在实际的工作流程中，这样的个人优化并不会直接把5天的需求变为3天。因为开发后还需要进行多个步骤，如前/后端联调、需求验收、测试用例编写等，因此个人的单点优化很难对整个项目产生显著的影响。
因此，面向全流程优化的关键在于采取一个全面的视角，关注整个团队和协作流程的改进。只有当我们从整体出发，全面优化各个团队的工作流程和协同机制，我们才能真正实现缩短交付周期、提高效率和质量的目标。
产研阶段不同应对的问题不同 在进行分阶段优化时，各个企业在需求、研发和运维这些关键阶段通常都已经拥有一些成熟的解决方案或产品。例如，在需求阶段，企业通常会利用需求管理和排期管理工具；而在研发阶段，则广泛采用各种成熟的CI/CD工具（这个阶段进一步细分为多个子阶段，每个子阶段都有其特定的目标和潜在的提升点）。为了有效地进行优化，首先需要建立一个清晰的流程规范，明确各个阶段的具体任务和目标。随后，将这些明确的规范转化为线上化的操作，通过人力资源的有效配置，以自动化的方式实现效率和质量的双重提升。
不同业务形态和基础环境面对的问题不同 总结起来，优化方向主要有两个：首先是全面提升产研协同的效率，其次是通过建立标准化、线上化，进而实现自动化的过程进行优化。然而，根据不同公司和业务形态的具体情况，这两方面的具体感受和需求也会有所不同。
以美团的业务技术形态为例，早期时，技术栈主要是Native和Web独立运营，各个团队“各自为政”，效率和质量的提升很大程度上取决于团队的规范执行情况和个人的编码习惯。因此，这一阶段最主要的痛点在于缺乏统一的标准和最佳实践。
进入中期，开始逐渐采用动态化技术，一些需求也开始具备跨iOS和Android的能力。发版模式从原先的Native“火车发版”转变为动态发版，产研交付的频次大幅增加，从两周一版变成了一周甚至一天一版。这一变化极大地考验了团队的协同能力和快速发版的能力。因此，这个阶段的挑战在于如何通过工具化的方式有效整合资源，以及如何适应快速变化和发展的节奏。
目前阶段，美团的业务已全面拥抱动态化，并在多个场景下实现了一码多端的能力。从之前的iOS、Android到现在的多端对齐，研发的差异性和管理成本、质量风险都有所增加。因此，当前阶段的核心问题是如何通过一套统一且通用的自动化方案，来实现整体效率的提升和质量的保障。
演进策略概览 带着这些挑战，我们来看下技术演进的概览。在初始阶段，我们通过标准化解决缺乏统一标准和最佳实践的问题的策略。进入中期，我们重点实施了工具化和线上化策略，以应对产研协同过程中出现的挑战。当前阶段，我们正专注于利用综合的大前端DevOps方法，旨在统一跨技术栈的流程并显著提升效率。
2 标准化 什么是标准化？为什么要做标准化？为什么大家都是共同实践出来的经验，A说的就是标准，B说的就不标准？带着这些问题我们这里先展开标准化的建设过程。
标准化背景 如图中所示，前端标准化实施之前，从业务规范到技术选型，差异显著，且难以判断各种方案的优劣，每个团队均根据自身的经验实施各异的实践。&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Mar 12, 2024</div>
					<a class="title" href="/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD%E5%9C%A8%E7%BE%8E%E5%9B%A2%E5%B1%A5%E7%BA%A6%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/">分布式因果推断在美团履约平台的探索与实践</a> &mdash;
					<span class="description">
						
						1. 业务背景 近年来，因果推断在商品定价、补贴、营销等领域得到广泛应用并取得了显著的业务效果提升，例如用户增长、活动营销等业务场景。这些领域的共性是需要“反事实推断能力”，传统机器学习算法更关注预测问题，而因果推断提供了更佳的反事实推断能力。以营销活动为例，我们不仅需要知道当前优惠券金额下，订单数是多少（预测问题），还要知道在改变金额的情况下，订单数会发生怎样的变化（反事实问题）。
常见的因果建模方法主要包含Meta-Learner、深度表征学习和Tree-Base算法三大类。其中以因果树为代表的Tree-Base算法泛化性强，适用于多种业务场景。相较于Meta-Learner，树模型建模流程简单；相较于深度表征学习，树模型特征处理和调参过程简单并且具备极强的可解释性。
开源社区涌现出了微软的EconML和DoWhy，Uber的CausalML，以及因果森林作者的grf-lab等等众多优秀开源项目，但这些项目均为单机实现，不能满足工业场景下亿级样本的模型训练、评估、解释分析。Meta-Learner和深度表征学习可以轻松借助XGBoost、LGBM、Spark MLlib、Tensorflow等开源工具支持海量数据，但是这些项目都不支持因果树相关的Tree-Base算法的分布式训练。
具体来说，XGBoost、LGBM、Spark Random Forest等树模型是为解决预测问题而提出的经典算法实现，而因果树算法引入了新的训练理论以及因果理论独有的干预变量、工具变量等概念。这意味着我们并不能通过对现有分布式树模型的简单改造，来实现因果理论下树模型的分布式训练，而是需要充分理解各类单机因果树算法的原理之后，选择合适的分布式编程范式高效地实现出来。
为了解决上述问题，美团履约平台技术部对开源项目进行了精细梳理，集各家之所长实现了一套高性能的分布式因果森林框架，在半小时内即可完成亿级样本100棵树的训练，突破了单机开源项目仅支持百万级样本的瓶颈。并经过复杂的抽象设计，最终实现通过自定义损失函数即可支持各类因果森林算法的能力，极大提升了框架的扩展性。
除此之外，美团履约平台技术部还在因果效应评估、观测数据去偏等方面建设了大量高效实用的分布式工具。本文将重点为大家分享如何设计实现一个分布式的因果森林算法，以及因果效应评估方面的经验技巧，将我们在分布式因果推断领域的一些探索和内部的实践经验分享给大家。
2. 分布式因果森林框架 因果森林算法的提出引发了Tree-Base算法应用于因果建模的研究热潮，众多学者相继在因果森林的基础上提出了多种多样的改进算法。监督学习领域的树模型有众多优秀的开源分布式实现，例如Xgboost、LightGBM、Spark Random Forest等等。
但是开源的因果树模型分布式实现基本处于空白状态。因果树算法引入了新的训练理论（比如Honesty Tree）并且因果树的分裂还依赖于干预变量、工具变量，这导致我们无法通过对现有分布式树实现做简单来更改来实现。因此，我们立足于论文，充分调研并借鉴业内优秀的开源实现，最终设计实现了一套高性能的分布式框架，并能提供统一的Serving方案。
借助这套框架，新增因果森林类算法只需要专注于损失函数设计即可，完全不必考虑分布式的工程实现。截止到目前，我们已经实现了四种因果森林算法，能够灵活支持多维连续treatment和及工具变量，半小时内即可完成亿级样本100棵树的训练。下面我们将从技术选型与框架设计、性能优化、Serving实现这几个方面为大家介绍这套框架。
2.1 技术选型与框架设计 单机树模型的工程实现可以概括为：遍历所有潜在的切分点并计算分裂指标（损失函数），取指标指标最佳的分裂点分裂，不断分裂树节点直到满足退出条件。而分布式环境下每台机器只包含部分样本，分布式环境下任何全局指标计算都会带来极大的通讯成本，因此需要选择合适的分布式架构帮助我们计算分裂指标。&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Mar 12, 2024</div>
					<a class="title" href="/posts/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%8F%98%E5%BC%82%E7%9A%84app%E5%81%A5%E5%A3%AE%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/">基于接口数据变异的App健壮性测试实践</a> &mdash;
					<span class="description">
						
						01 什么是客户端健壮性 在维基百科的定义中，健壮性（Robustness）是指一个计算机系统在执行过程中处理错误，以及算法在遭遇输入、运算等异常时继续正常运行的能力。IEEE中将健壮性定义为系统或组件在存在无效输入或压力环境条件下可以正常运行的程度。早在1989年，Barton Miller首次提出了模糊测试的概念，通过向目标应用抛出随机字符串的方式来测试UNIX应用程序的健壮性；而在1996年的Ballista项目中，研究人员探索根据API定义的数据类型，对操作系统或软件接口进行自动化测试方法。两个项目均以“无应用程序崩溃或挂起”作为测试验证通过的标准。
在移动端App领域，健壮性可以理解为App运行时遭遇环境异常或者输入异常时客户端能够继续正常运行的能力。
其中，环境异常主要分为操作系统异常、外部环境异常、硬件环境异常三大类。比如内存不足、CPU负载过高、线程池满载、内存分配失败、网络连接失败等。输入异常主要分为系统输入和用户输入。比如网络接口返回的数据异常、应用内缓存、数据库文件读写异常，这类的异常属于在系统输入异常；在电话号码输入框场景，用户输入的空格、富文本则属于用户输入异常。
对于这些风险，如果App没有处理，理论上都可能会产生展示异常、交互异常、性能、安全等问题，导致用户无法继续使用或在使用过程中产生不好的体验。比如用户操作App下单过程中，API请求出现故障未返回状态码为200的响应，App由于没有获取到预期接口响应的信息而发生崩溃，就会中断用户的使用流程。
02 基于接口数据变异的App健壮性测试方案设计 在实际的客户端测试执行过程中，测试人员会考虑测试异常输入的场景，但由于成本无法做到无穷尽的测试，同时还存在人工执行遗漏的风险。
从美团App平台业务的历史故障分析中，我们发现：网络请求返回的数据与实现预期不符引发的Crash或核心功能缺失问题导致的故障占比最高，且影响面较广。比如接口返回非预期数据时，客户端处理数据类型转换异常导致闪退，即使5分钟内操作降级仍影响了百万量级的用户。因此美团平台业务App的健壮性测试探索优先从发现网络请求返回数据导致的异常开始。
针对于发现请求接口返回客户端非预期数据导致的Crash，或者核心模块缺失问题这个诉求，我们调研后发现方案的基本原理都是相似的，即以网络请求的原始响应为基础，根据规则进行变异构造，使用代理工具改写响应体返回给客户端，在端上设备做异常检测。但是都存在一些问题不能满足诉求，比如测试变异数据是根据预置或者自定义规则随机生成组合，随机性过大，不能有效拦截健壮性问题；但如果不做随机，产生的用例组合量过大，测试不能在合理时间范围内结束；另外在检测能力方面，不具备发现业务异常或功能模块异常的能力。
因此，我们结合通用方案做了一些自定义改造，整体检测方案包含静态检测和动态检测两部分。
静态检测，主要是指静态代码扫描，将典型代码编写规范问题转化为自定义静态代码扫描规则，管控增量代码，同时长期治理存量风险。比如自定义了PrimitiveParseDetector、ColorParseDetector，管控业务必须使用健壮性测试通过的工具类。 动态检测是指结合触发时机，构造并注入变异数据后，识别App运行时是否出现崩溃、挂起或业务功能模块异常。比如在集成事件/回归事件触发自动化测试运行，构造触发异常的数据进行动态测试，然后监测是否出现了异常。核心动作包含构造变异数据和完成检测两部分。比如将接口响应体中表示颜色含义的Key对应的Value值构造成非色值，然后检测客户端请求处理接口数据时是否出现崩溃或挂起。 下文重点介绍端到端的动态检测方案。
03 变异数据的构造和异常检测 对于美团App来说，首页有多种形态，对于某种特定形态，除了控制请求数据外还需要控制实验、策略等一系列因素，才能保证测试对象的唯一性。一个页面中包含多个异步请求，因此请求的构造也需要和页面路径关联。这些都是采集变异所需的基础数据时需要关注和控制的。
响应体由基本类型数据和复合类型数据组成，相同基本类型的数据可能具备不同的业务语义，需要根据语义的类型做变异规则的区分对待，才能保障业务场景覆盖。&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Mar 12, 2024</div>
					<a class="title" href="/posts/%E7%BE%8E%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%B9%B4%E8%B4%A7--600&#43;%E9%A1%B5%E7%94%B5%E5%AD%90%E4%B9%A6%E5%89%8D%E7%AB%AF%E5%90%8E%E7%AB%AF%E7%AE%97%E6%B3%95%E6%B5%8B%E8%AF%95%E8%BF%90%E7%BB%B4%E7%B3%BB%E5%88%97%E5%A4%A7%E5%90%88%E9%9B%86/">美团技术年货 | 600&#43;页电子书，前端、后端、算法、测试、运维系列大合集</a> &mdash;
					<span class="description">
						
						新春将至，一年一度的美团技术年货也如期到来！
星海横流，岁月成碑。2023年，美团技术博客走过了整整十个春秋，累计发布了580多篇技术文章，感谢大家的一路相伴。
在龙年春节到来之际，我们精选过去一年公众号30多篇技术文章和科研论文，整理制作成一本600多页的电子书，作为新年礼物赠送给大家。
这本电子书内容覆盖算法、后端、前端、测试、运维等多个技术领域， 希望能对同学们的工作和学习有所帮助。也欢迎大家转给更多有相同兴趣、积极上进的同事和朋友们，一起切磋，共同成长。
面对未来，希望大家有「无惧前路雨潇潇」的勇气，也兼具「乘风破浪会有时」的魄力。
知不足而奋进，望远山而力行。祝愿大家在甲辰龙年，幸福平安，行稳致远。
如何获取？ 温馨提示：
美团技术年货合集大小约为100M，下载需要一些时间； 打开电子书目录后，可直接点击感兴趣的标题进行阅读； 部分文章中的动态图片无法在电子书中进行完全的展示，大家可以移步美团技术团队官方博客 tech.meituan.com ，或在美团技术团队公众号历史文章中进行阅读，感谢理解。 往期技术年货下载 关注「美团技术团队」微信公众号。回复【2022年货】、【2021年货】、【2020年货】、【2019年货】、 【2018年货】、【2017年货】，即可获取往期年货下载链接。&hellip;
						
					</span>
				</div>
				
				

<ul class="pagination">
	<li class="page-item page-prev">
	
    <a href="/page/4/" class="page-link" aria-label="Previous"><span aria-hidden="true">← Prev page</span></a>
	
	</li>
	<li class="page-item page-next">
	
    <a href="/page/6/" class="page-link" aria-label="Next"><span aria-hidden="true">Next page →</span></a>
	
	</li>
</ul>


			</div>
		</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="">Wfsui theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div><script>feather.replace()</script>
</body>
</html>
