<!DOCTYPE html>
<html>
<head>
	<meta name="generator" content="Hugo 0.128.0">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>大峰哥 - 记录日常生活哦 </title><meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="alternate" type="application/rss+xml" href="https://wfsui.github.io/index.xml" title="大峰哥" />
	<meta property="og:url" content="https://wfsui.github.io/">
  <meta property="og:site_name" content="大峰哥">
  <meta property="og:title" content="大峰哥">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="website">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="大峰哥">
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/main.css" /><link rel="stylesheet" type="text/css" href="https://wfsui.github.io/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="https://wfsui.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	<base href="https://wfsui.github.io/">
	<h1 class="site-title"><a href="https://wfsui.github.io/">大峰哥</a></h1>
	<div class="site-description"><h2>记录日常生活哦</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/wfsui" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">首页</a>
			</li>
			
			<li>
				<a href="/posts">文章</a>
			</li>
			
			<li>
				<a href="/about">关于</a>
			</li>
			
			<li>
				<a href="/tags">标签</a>
			</li>
			
		</ul>
	</nav>
</div>


		

		<div class="recent-posts section">
			<h2 class="section-header">
				Recent posts
			</h2>
			<div class="posts">
				
				
				
				<div class="post">
					<div class="meta">Jun 28, 2024</div>
					<a class="title" href="/posts/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1ddd%E5%9C%A8b%E7%AB%AF%E8%90%A5%E9%94%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E8%B7%B5/">领域驱动设计DDD在B端营销系统的实践</a> &mdash;
					<span class="description">
						
						1 背景 通过营销活动实现客户/用户拉新、留存和促活是业界普遍采用的方法。为实现商户增长和留存，美团核心本地商业/商业增值技术部也构建了相应的营销系统来支撑商户的线上营销运营。在系统建设过程中，面临着业务体量大、行业跨度大、场景多样、客户结构复杂，需求多变等挑战。本文试图还原从0到1构建面向商户的营销系统过程中，并通过DDD（领域驱动设计）来应对系统设计和建设中遇到的业务复杂度高、需求多变、维护成本大等问题。
2 基本概念 软件系统的复杂性主要体现在三个方面。
隐晦：一是抽象层面的隐晦，抽象系统时，每个人都有自己特定的视角，你需要站在对方的角度才能明白他为什么这么做；其次是实现层面的隐晦，代码是一种技术实现，通常与现实世界的业务概念脱节，无形中增加了理解成本。 耦合：代码层面的耦合扩大了修改范围；模块层面的耦合需要跨模块/服务交互；系统层面的耦合则需要跨团队协作。从代码到模块再到系统，耦合的影响逐渐扩大，成本随之增加。 变化：业务需求决定了系统功能，不同的用户需求不一样，不同的业务发展阶段需求在不断变化，系统功能要随着业务需求的变化不断调整，这时就涉及到系统改动的频次和范围。 DDD（Domain-Driven Design，领域驱动设计）是应对软件设计复杂性的方法之一，它能很好的解决上述三个问题，但其概念体系复杂（如下图所示），学习曲线陡峭，即便深入研读DDD的两本经典著作，项目落地时依然有点“捉襟见肘”。
在展开介绍DDD之前，这里先回顾一下历史：
早期，计算机创新更多聚焦在语言方面，为软件工程师提供功能更强大的语言来操作计算机，充分使用计算机的算力。 60年代，面向对象语言诞生，通过封装、继承、多态等特性进一步增强了语言的表达能力。 80年代，出现面向对象的分析与设计，解决了如何构建类模型的问题，帮助我们更好地使用面向对象语言来实现系统，但没有解决如何把物理世界映射到计算机世界的问题。 2000年，出现领域驱动设计方法，通过分析业务，抽取概念，建立对应的领域模型，再采用面向对象的分析与设计方法构建对应的类模型，达成了从物理世界到计算机世界的映射。 什么是领域？领域由三部分组成：领域里有用户，即涉众域；用户要实现某种业务价值，解决某些痛点或实现某种诉求，即问题域；面对业务价值，痛点和诉求，有对应的解决方案，这是解决方案域。什么是领域驱动设计？通俗地讲，针对特定业务，用户在面对业务问题时有对应的解决方案，这些问题与方案构成了领域知识，它包含流程、规则以及处理问题的方法，领域驱动设计就是围绕这些知识来设计系统。
以营销为例，营销系统所服务的用户有4类：运营、销售、电销人员和商户。解决3个核心问题：如何发券、发给谁、发什么（红包还是折扣券）。解决方案：通过营销活动来承载发券，不同的活动类型对应不同的玩法（如买赠、折扣、充送等）；通过目标人群来确定发给谁；通过权益来定义发什么（如：红包、代金券、折扣券等）。
本文将从战略设计、战术设计和代码架构分3个部分介绍领域驱动设计的落地：
战略设计：确定用例，统一语言和划分边界。 战术设计：概念模型转化成类（代码）模型。 代码架构：将系统设计映射为系统实现。 3 战略设计实践 战略设计之前，先要确定用例，也就是业务是怎么玩的，有几种常见的方法：&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Jun 28, 2024</div>
					<a class="title" href="/posts/cvpr-2024--%E7%BE%8E%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%B2%BE%E9%80%89%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/">CVPR 2024 | 美团技术团队精选论文解读</a> &mdash;
					<span class="description">
						
						CVPR全称为IEEE Conference on Computer Vision and Pattern Recognition，国际计算机视觉与模式识别会议。该会议始于1983年，与ICCV和ECCV并称计算机视觉方向的三大顶级会议。根据谷歌学术公布的2022年最新学术期刊和会议影响力排名，CVPR在所有学术刊物中位居第4，仅次于Nature、NEJM和Science。
本文精选了美团技术团队被CVPR 2024收录的7篇论文进行解读，这些论文既包括OCR预训练、长尾半监督学习等基础学习范式升级，也包括图生视频、数字人驱动、视听分割（AVS）等视觉AIGC技术创新。这些论文有美团视觉智能部的独立产出，也有跟高校、科研机构合作的成果。希望能给从事相关研究工作的同学带来一些帮助或启发。
01 | ODM: A Text-Image Further Alignment Pre-training Approach for Scene Text Detection and Spotting 论文作者：Chen Duan（Meituan），Pei Fu（Meituan），Shan Guo（Meituan），Qianyi Jiang（Meituan），Xiaoming Wei（Meituan）&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Jun 28, 2024</div>
					<a class="title" href="/posts/spark%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%9E%E8%B7%B5/">Spark向量化计算在美团生产环境的实践</a> &mdash;
					<span class="description">
						
						1 什么是向量化计算 1.1 并行数据处理：SIMD指令 让我们从一个简单问题开始：假设要实现“数组a+b存入c”，设三个整型数组的长度都是100，那么只需将“c[i] = a[i] + b[i]”置于一个100次的循环内，代码如下：
void addArrays(const int* a, const int* b, int* c, int num) { for (int i = 0; i &lt; num; ++i) { c[i] = a[i] + b[i]; } } 我们知道：计算在CPU内完成，逻辑计算单元操作寄存器中的数据，算术运算的源操作数要先放置到CPU的寄存器中，哪怕简单的内存拷贝也需要过CPU寄存器。所以，完成“c[i] = a[i] + b[i]”需经三步：&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Jun 28, 2024</div>
					<a class="title" href="/posts/%E5%92%B1%E4%BB%AC%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E8%AE%B2%E4%B8%80%E6%AC%A1-flink-%E7%BD%91%E7%BB%9C%E6%B5%81%E6%8E%A7%E5%92%8C%E5%8F%8D%E5%8E%8B%E5%89%96%E6%9E%90/">咱们从头到尾讲一次 Flink 网络流控和反压剖析</a> &mdash;
					<span class="description">
						
						作者：张俊
整理：张友亮（Apache Flink 社区志愿者）
本文共 4745字，预计阅读时间 15min。
本文根据 Apache Flink 系列直播整理而成，由 Apache Flink Contributor、OPPO 大数据平台研发负责人张俊老师分享。主要内容如下：
网络流控的概念与背景 TCP的流控机制 Flink TCP-based 反压机制（before V1.&hellip;
						
					</span>
				</div>
				
				<div class="post">
					<div class="meta">Jun 28, 2024</div>
					<a class="title" href="/posts/jpa-%E5%92%8C-mybatis-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/">JPA 和 Mybatis 技术选型</a> &mdash;
					<span class="description">
						
						在我们平时的项目中，大家都知道可以使用 JPA 或者 Mybatis 作为 ORM 层。对 JPA 和 Mybatis 如何进行技术选型？
下面看看大精华总结如下：
最佳回答
首先表达个人观点，JPA必然是首选的。
个人认为仅仅讨论两者使用起来有何区别，何者更加方便，不足以真正的比较这两个框架。
要评判出更加优秀的方案，我觉得可以从软件设计的角度来评判。
个人对 mybatis 并不熟悉，但 JPA 规范和 springdata 的实现，设计理念绝对是超前的。软件开发复杂性的一个解决手段是遵循 DDD（DDD 只是一种手段，但不是唯一手段），而我着重几点来聊聊 JPA 的设计中是如何体现领域驱动设计思想的，抛砖引玉。&hellip;
						
					</span>
				</div>
				
				

<ul class="pagination">
	<li class="page-item page-prev">
	
    <a href="/page/4/" class="page-link" aria-label="Previous"><span aria-hidden="true">← Prev page</span></a>
	
	</li>
	<li class="page-item page-next">
	
    <a href="/page/6/" class="page-link" aria-label="Next"><span aria-hidden="true">Next page →</span></a>
	
	</li>
</ul>


			</div>
		</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="">Wfsui theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div><script>feather.replace()</script>
</body>
</html>
